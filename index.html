<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>CATALYST</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
    @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Orbitron:wght@400;700;900&display=swap');
    body {
      * {
    -webkit-tap-highlight-color: transparent;
    -webkit-touch-callout: none; /* Mencegah menu konteks saat tekan lama */
    outline: none;
}

        margin: 0;
        overflow: hidden;
        background-color: #000;
        font-family: 'Orbitron', sans-serif;
        touch-action: none;
        user-select: none;
        -webkit-user-select: none;
        background-color: #000; 
        background-size: cover;
        font-family: 'Orbitron', sans-serif;
        touch-action: none;
        user-select: none;
        -webkit-user-select: none;
        background-position: center center;
        background-repeat: no-repeat;
        background-attachment: fixed; /* Agar background diam saat ada elemen bergerak */
        background-size: cover;       /* Memenuhi layar */
    
    }

    #gameCanvas {
        display: block; width: 100%; height: 100vh; background: transparent; 
    }
    /* --- NEW ANIMATIONS --- */
    
    /* 1. Transisi Background Smooth */
    #loading-layer {
        transition: opacity 1.5s ease-in-out; /* Durasi fade out background hitam */
    }

    /* 2. Animasi Container Kartu (Drop dari atas) */
    .drop-in-animation {
        animation: dropDownBounce 1.5s cubic-bezier(0.25, 1, 0.5, 1) forwards;
    }
/* Animasi Gelombang Cahaya */
@keyframes shadowPulse {
    0% {
        filter: brightness(1) grayscale(0) drop-shadow(0 5px 15px rgba(200, 90, 255, 0.6));
    }
    50% {
        /* Saat di tengah animasi, shadow melebar dan lebih terang */
        filter: brightness(1.1) grayscale(0) drop-shadow(0 10px 35px rgba(200, 90, 255, 0.9));
    }
    100% {
        filter: brightness(1) grayscale(0) drop-shadow(0 5px 15px rgba(200, 90, 255, 0.6));
    }
}

    @keyframes dropDownBounce {
        0% {
            transform: translateY(-150vh); /* Mulai dari jauh di atas layar */
            opacity: 0;
        }
        60% {
            transform: translateY(30px); /* Sedikit membal ke bawah */
            opacity: 1;
        }
        100% {
            transform: translateY(0); /* Posisi normal */
            opacity: 1;
        }
    }



/* Class khusus untuk kartu yang sedang aktif/di tengah */
.carousel-item.active img {
    animation: naturalFloat 3s ease-in-out infinite;
    
}





    /* --- UI LAYER UMUM --- */
    #ui-layer, #loading-layer {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        display: flex; flex-direction: column;
        justify-content: center; align-items: center;
        pointer-events: none;
    }
    
    #lobby-screen {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        display: flex; flex-direction: column;
        justify-content: center; align-items: center;
        z-index: 200;
        pointer-events: auto;
        
        /* BACKGROUND LOBBY */
        background-image: url('https://github.com/viqihakbarrr-cyber/CATALYST/blob/main/BgLobby.jpg?raw=true');
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
    }

    /* --- CAROUSEL MODE SELECTOR & MATCHMAKING UI --- */
    .carousel-container {
        position: relative;
        width: 100%;
        height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        overflow: hidden;
        perspective: 1000px;
    }

    .carousel-track {
        display: flex;
        align-items: center;
        justify-content: center;
        width: max-content; 
        cursor: grab;
    }
    
    .carousel-track:active {
        cursor: grabbing;
    }

     /* --- MODE CARD STYLE BARU (UPDATED) --- */
    .mode-card {
        width: 250px; 
        height: 400px; 
        margin: 0 10px; /* Total lebar = 250 + 20 = 270px */
        background-color: transparent !important; 
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        border: none !important;
        border-radius: 15px;
        box-shadow: none !important; 
        position: relative;
        
        /* Default state: Gelap, kecil, datar */
        transform: scale(0.85) perspective(1000px) rotateX(0deg);
        filter: brightness(0.5) grayscale(0.5); 
        opacity: 1;
        
        transition: transform 0.6s cubic-bezier(0.34, 1.56, 0.64, 1), 
                    filter 0.6s ease,
                    opacity 0.6s ease;
        z-index: 1;
        
        

        transform: perspective(600px) rotateX(0deg) scale(0.85);
        
        /* State awal: bayangan tipis/hitam biasa */
        filter: brightness(0.5) grayscale(0.5) drop-shadow(0 0 0px rgba(0,0,0,0));
        
        transition: transform 0.6s cubic-bezier(0.34, 1.56, 0.64, 1), 
                    filter 0.6s ease,
                    opacity 0.6s ease;
    }

        
        
    .mode-card.active {
    transform: perspective(600px) rotateX(25deg) scale(1.1) translateY(-10px) !important;
    z-index: 10;
    box-shadow: none !important;
    border: none !important;

    /* MEMANGGIL ANIMASI */
    /* duration 3s, linear, berulang selamanya (infinite) */
    animation: shadowPulse 3s infinite ease-in-out;
}

    .mode-card.faded-out {
        opacity: 0;
        pointer-events: none;
        transform: scale(0.5) translateY(100px); /* Turun ke bawah saat hilang */
    }


    /* Layer Gelap untuk Background */
    .mode-card::after {
        content: '';
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        background: rgba(0, 0, 0, 0);
        transition: background 0.5s ease;
        border-radius: 15px;
        z-index: 0;
        pointer-events: none;
    }

    .mode-card.active {
        transform: scale(1.05); 
        filter: brightness(1); 
        z-index: 10;
    }

    /* --- TAHAP ANIMASI SEARCHING --- */
    /* Tahap 1: Rotasi */
    .mode-card.anim-rotate {
        transform: scale(1.05) rotate(180deg) !important;
        z-index: 100 !important;
    }

    /* Tahap 2: Pindah ke Atas & Gelap */
    .mode-card.anim-searching {
        transform: translateY(-85vh) rotate(180deg) scale(2) !important; 
        z-index: 100 !important;
        filter: brightness(1) !important; 
    }

    .mode-card.anim-searching::after {
        background: rgba(0, 0, 0, 0.0);
        
    }

    /* --- OVERLAY TEXT & BUTTON --- */
    .search-overlay {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        display: flex; flex-direction: column;
        justify-content: flex-end; 
        align-items: center;
        padding-bottom: 40px;
        
        opacity: 0; 
        pointer-events: none;
        transition: opacity 0.5s ease;
        z-index: 5;
        transform: rotate(180deg); /* Teks dibalik agar terbaca saat kartu terbalik */
    }

    .mode-card.anim-searching .search-overlay {
        opacity: 1; 
        pointer-events: auto;
    }

  /* --- UI MATCHMAKING TERPISAH (BARU) --- */
#matchmaking-ui {
    position: absolute;
    top: 2%; /* Posisi tetap di bagian atas layar */
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    flex-direction: column;
    align-items: center;
    z-index: 500; /* Lebih tinggi dari kartu */
    pointer-events: auto;
    transition: opacity 0.5s ease;
}

#matchmaking-ui.hidden {
    display: none;
    opacity: 0;
}

/* Style Text & Button (Diambil dari yang lama tapi disederhanakan) */
.searching-label {
    font-size: 14px; /* Sedikit diperbesar agar jelas */
    color: #00FF00; 
    letter-spacing: 3px;
    margin-bottom: 5px; 
    text-transform: uppercase;
    font-weight: bold;
    text-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
    animation: pulseText 1.5s infinite;
}

.timer-text {
    font-size: 24px; /* Diperbesar */
    color: #fff; 
    font-weight: 900;
    text-shadow: 0 0 15px rgba(255, 255, 255, 0.8);
    margin-bottom: 20px;
    font-family: 'Orbitron', sans-serif;
}

.cancel-btn {
    width: 20px; height: 20px; /* Diperbesar agar mudah ditekan */
    border: 1.4px solid #ffff;
    color: #ffff;
    border-radius: 50%;
    font-weight: bold; 
    cursor: pointer;
    display: flex; justify-content: center; align-items: center;
    background: rgba(0,0,0,0.2);
    transition: all 0.2s;
    font-size: 11px;
    margin-left: 170px;
    margin-top: -30px;
    
    /* Animasi muncul tombol cancel */
    opacity: 0; 
    pointer-events: none;
    transition: opacity 0.5s ease 2s; /* Delay 2 detik baru muncul */
}


/* Class active untuk memunculkan tombol cancel */
#matchmaking-ui.active-cancel .cancel-btn {
    opacity: 1;
    pointer-events: auto;
}

.cancel-btn:hover {
    background: #aaa;
    color: white;
    box-shadow: 0 0 15px #aaaa;
}
    
    @keyframes pulseText {
        0% { opacity: 0.5; }
        50% { opacity: 1; }
        100% { opacity: 0.5; }
    }
    /* --- LOADING SCREEN UPDATE --- */
    #loading-layer {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        display: flex; flex-direction: column;
        justify-content: flex-end; 
        align-items: center;
        z-index: 9999; /* Pastikan di paling atas */
        background-color: #000000; /* Background Hitam Sesuai Request */
        
        /* Splash.png Responsif & Selalu di dalam Frame */
        background-image: url('https://github.com/viqihakbarrr-cyber/kkk/blob/main/Splash.png?raw=true');
        background-size: contain; 
        background-position: center;
        background-repeat: no-repeat;
    }

    /* Sembunyikan canvas saat masih loading agar background game tidak bocor */
    #gameCanvas {
        display: none; /* Akan diubah ke block via JS jika game dimulai */
        width: 100%; height: 100vh; background: transparent; 
    }

    .loading-container { width: 80%; max-width: 600px; margin-bottom: 50px; text-align: center; }
    .loading-detail-text { color: #ffff; font-size: 14px; font-weight: bold; margin-bottom: 10px; text-shadow: 0 0 5px black; }
    .progress-bar-bg { width: 100%; height: 8px; background: rgba(0,0,0,0.7); border: 1px solid #333; border-radius: 10px; overflow:hidden; }
    .progress-bar-fill { height: 100%; width: 0%; background: linear-gradient(90deg, #ffff, #ffff); transition: width 0.2s; }

    #game-over {
        display: none; background: rgba(255, 255, 255, 0.95);
        padding: 40px; border-radius: 20px; text-align: center; border: 3px solid #333;
        pointer-events: auto; box-shadow: 0 0 50px rgba(255, 255, 255, 0.5);
        position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
    }
    .main-btn { padding: 15px 30px; background: #000; color: white; border: none; border-radius: 50px; font-family: 'Orbitron'; cursor: pointer; }
    .btn-secondary { background: #555 !important; }
    
    /* Utility class hidden */
    .hidden { display: none !important; }
    
    
    /* --- SETTINGS UI --- */
#settings-btn {
    position: absolute;
    top: 20px;
    right: 20px;
    width: 40px;
    height: 40px;
    background: rgba(0, 0, 0, 0.5);
    border: 1px solid rgba(255, 255, 255, 0.3);
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    z-index: 1000; /* Di atas segalanya */
    transition: all 0.3s ease;
}

#settings-btn:hover {
    background: rgba(255, 255, 255, 0.1);
    transform: rotate(90deg);
    border-color: #fff;
}

#settings-modal {
    position: fixed;
    top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0, 0, 0, 0.85);
    backdrop-filter: blur(8px);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 2000;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
}

#settings-modal.active {
    opacity: 1;
    pointer-events: auto;
}

.settings-content {
    width: 90%;
    max-width: 400px;
    background: rgba(20, 20, 20, 0.95);
    border: 2px solid #333;
    border-radius: 15px;
    padding: 25px;
    box-shadow: 0 0 30px rgba(0, 255, 0, 0.1);
    position: relative;
    text-align: center;
    font-family: 'Orbitron', sans-serif;
    color: white;
}

.settings-title {
    font-size: 20px;
    font-weight: bold;
    margin-bottom: 20px;
    border-bottom: 1px solid #444;
    padding-bottom: 10px;
    letter-spacing: 2px;
}

.setting-row {
    margin-bottom: 20px;
    text-align: left;
}

.setting-label {
    font-size: 12px;
    color: #aaa;
    margin-bottom: 8px;
    text-transform: uppercase;
}

.quality-options {
    display: flex;
    gap: 10px;
}

.q-btn {
    flex: 1;
    padding: 8px 0;
    background: #111;
    border: 1px solid #444;
    color: #666;
    cursor: pointer;
    font-family: 'Orbitron';
    font-size: 10px;
    transition: all 0.2s;
}

.q-btn.active {
    background: #00FF00;
    color: #000;
    font-weight: bold;
    box-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
    border-color: #00FF00;
}

.fs-toggle-btn {
    width: 100%;
    padding: 10px;
    background: #333;
    border: 1px solid #555;
    color: white;
    font-family: 'Orbitron';
    cursor: pointer;
}

.about-text {
    font-size: 10px;
    color: #666;
    line-height: 1.4;
    margin-top: 10px;
    text-align: justify;
    background: #000;
    padding: 10px;
    border: 1px solid #222;
}

/* Tombol Close Style mirip Cancel Matchmaking */
.close-settings {
    position: absolute;
    top: 15px;
    right: 15px;
    width: 25px; 
    height: 25px;
    border: 1.4px solid #ffff;
    color: #ffff;
    border-radius: 50%;
    font-weight: bold; 
    cursor: pointer;
    display: flex; justify-content: center; align-items: center;
    background: rgba(0,0,0,0.2);
    transition: all 0.2s;
    font-size: 12px;
}
.close-settings:hover {
    background: #aaa;
    color: black;
    box-shadow: 0 0 10px #fff;
}

/* RESPOSIVE MOBILE ADJUSTMENT */
@media (max-width: 600px) {
    .settings-content {
        width: 85%;           /* Lebih ramping (dari 90%) */
        padding: 15px;        /* Padding lebih tipis */
        transform: scale(0.9); /* Kecilkan seluruh skala popup sebesar 10% */
    }
    
    /* Opsional: Kecilkan teks judul agar pas */
    .settings-title {
        font-size: 16px; 
        margin-bottom: 15px;
    }
}
/* --- EMOTE SYSTEM UI --- */
#emote-container {
    position: absolute;
    bottom: 80px; /* Sedikit diturunkan agar rapi */
    right: 20px;  /* PINDAHKAN KE KANAN (tadinya left: 20px) */
    left: auto;   /* Reset left */
    z-index: 2000;
    display: flex;
    flex-direction: column;
    align-items: flex-end; /* Ubah align ke kanan */
    
    /* PENTING: Container tidak boleh memblokir sentuhan */
    pointer-events: none; 
}

/* Tombol dan Picker harus bisa diklik */
.emote-btn-toggle, .emote-picker {
    pointer-events: auto; 
}


.emote-btn-toggle {
    width: 50px;
    height: 50px;
    background: rgba(0, 0, 0, 0.6);
    border: 2px solid #fff;
    border-radius: 50%;
    color: white;
    font-size: 24px;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    transition: all 0.2s;
    box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
}

.emote-btn-toggle:hover {
    transform: scale(1.1);
    background: rgba(255, 255, 255, 0.2);
}

/* Kotak Grid Pilihan Emote */
.emote-picker {
    display: grid;
    grid-template-columns: repeat(3, 1fr); /* 3 Kolom */
    gap: 5px;
    background: rgba(0, 0, 0, 0.9);
    padding: 10px;
    border-radius: 10px;
    border: 1px solid #444;
    margin-bottom: 15px; /* Jarak dari tombol toggle */
    
    /* Animasi Pop Up */
    opacity: 0;
    transform: scale(0.8) translateY(20px);
    pointer-events: none;
    transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    transform-origin: bottom left;
}

.emote-picker.active {
    opacity: 1;
    transform: scale(1) translateY(0);
    pointer-events: auto;
}

/* Individual Item di dalam Picker */
.emote-item {
    width: 50px;
    height: 50px;
    background-image: url('https://raw.githubusercontent.com/viqihakbarrr-cyber/CATALYST/main/emot.png');
    background-size: 300% 300%; /* Karena 3 baris x 3 kolom */
    cursor: pointer;
    border-radius: 5px;
    transition: transform 0.1s;
}

.emote-item:hover {
    transform: scale(1.2);
    background-color: rgba(255, 255, 255, 0.1);
}

/* Sembunyikan tombol saat di menu utama */
.hidden-ui {
    display: none !important;
}



    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="fs-toggle" onclick="toggleFullscreen()" style="position: absolute; bottom: 10px; right: 10px; z-index: 500; cursor: pointer;">
        <div id="fs-icon" style="width: 30px; height: 30px; background: rgba(255,255,255,0.2); border-radius: 5px; display: flex; align-items: center; justify-content: center;">
            <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: white;">
                <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/>
            </svg>
        </div>
    </div>
    
    <div id="settings-btn" onclick="openSettings()">
        <svg viewBox="0 0 24 24" style="width: 20px; height: 20px; fill: white;">
            <path d="M19.14,12.94c0.04-0.3,0.06-0.61,0.06-0.94c0-0.32-0.02-0.64-0.07-0.94l2.03-1.58c0.18-0.14,0.23-0.41,0.12-0.61 l-1.92-3.32c-0.12-0.22-0.37-0.29-0.59-0.22l-2.39,0.96c-0.5-0.38-1.03-0.7-1.62-0.94L14.4,2.81c-0.04-0.24-0.24-0.41-0.48-0.41 h-3.84c-0.24,0-0.43,0.17-0.47,0.41L9.25,5.35C8.66,5.59,8.12,5.92,7.63,6.29L5.24,5.33c-0.22-0.08-0.47,0-0.59,0.22L2.74,8.87 C2.62,9.08,2.66,9.34,2.86,9.49l2.03,1.58C4.84,11.36,4.8,11.69,4.8,12s0.02,0.64,0.07,0.94l-2.03,1.58 c-0.18,0.14-0.23,0.41-0.12,0.61l1.92,3.32c0.12,0.22,0.37,0.29,0.59,0.22l2.39-0.96c0.5,0.38,1.03,0.7,1.62,0.94l0.36,2.54 c0.05,0.24,0.24,0.41,0.48,0.41h3.84c0.24,0,0.44-0.17,0.47-0.41l0.36-2.54c0.59-0.24,1.13-0.56,1.62-0.94l2.39,0.96 c0.22,0.08,0.47,0,0.59-0.22l1.92-3.32c0.12-0.22,0.07-0.47-0.12-0.61L19.14,12.94z M12,15.6c-1.98,0-3.6-1.62-3.6-3.6 s1.62-3.6,3.6-3.6s3.6,1.62,3.6,3.6S13.98,15.6,12,15.6z"/>
        </svg>
    </div>

    <div id="settings-modal">
        <div class="settings-content">
            <div class="close-settings" onclick="closeSettings()">X</div>
            <div class="settings-title">SYSTEM SETTINGS</div>

            <div class="setting-row">
                <div class="setting-label">Graphics Quality</div>
                <div class="quality-options">
                    <button class="q-btn" id="q-low" onclick="setQuality('low')">LOW</button>
                    <button class="q-btn" id="q-med" onclick="setQuality('medium')">MED</button>
                    <button class="q-btn active" id="q-high" onclick="setQuality('high')">HIGH</button>
                </div>
            </div>

            <div class="setting-row">
                <div class="setting-label">Display Mode</div>
                <button class="fs-toggle-btn" onclick="toggleFullscreen()">TOGGLE FULLSCREEN</button>
            </div>

            <div class="setting-row">
                <div class="setting-label">About Catalyst</div>
                <div class="about-text">
                    CATALYST v1.0<br>
                    A real-time cyberpunk card battler.<br>
                    Developed by Viqih Akbar.<br>
                    &copy; 2026 All Rights Reserved.
                </div>
            </div>
        </div>
    </div>

    <div id="loading-layer">
        <div class="loading-container">
            <div class="loading-detail-text" id="loading-text-detail">INITIALIZING SYSTEM... 0%</div>
            <div class="progress-bar-bg">
                <div class="progress-bar-fill" id="loading-bar-fill"></div>
            </div>
        </div>
    </div>
<div id="lobby-screen" class="hidden">
    
    <div id="matchmaking-ui" class="hidden">
        <div class="searching-label" id="mm-label">FINDING MATCH</div>
        <div class="timer-text" id="mm-timer">00:00</div>
        <div class="cancel-btn" onclick="cancelMatchmaking(event)">X</div>
    </div>
    <div class="carousel-container" id="carousel-container">
        <div class="carousel-track" id="track">
            
            <div class="mode-card" id="card-ranked" 
                 style="background-image: url('https://github.com/viqihakbarrr-cyber/CATALYST/blob/main/Mclassic.png?raw=true');">
                 </div>

            <div class="mode-card active" id="card-classic" 
                 style="background-image: url('https://github.com/viqihakbarrr-cyber/CATALYST/blob/main/Mclassic.png?raw=true');">
                 </div>

            <div class="mode-card" id="card-friend" 
                 style="background-image: url('https://github.com/viqihakbarrr-cyber/CATALYST/blob/main/Mclassic.png?raw=true');">
                 </div>

        </div>
    </div>
    
    <div id="search-status" style="position:absolute; bottom:20px; color:rgba(255,255,255,0.5); font-size:10px;"></div>
    <div id="queue-position" style="position:absolute; bottom:5px; color:rgba(255,255,255,0.5); font-size:10px;"></div>
    <div id="connecting-status" style="position:absolute; top:80px; color:#00FF00; font-size:12px;"></div>
</div>


 <div id="ui-layer">
    <div id="game-over">
        <h1 id="winner-text">YOU WIN!</h1>
        <p id="sub-winner-text" style="color:#666; margin-bottom:20px;">Opponent Disconnected</p>
        <button id="btn-rematch" class="main-btn active" onclick="requestRematch()">REMATCH</button>
        <br><br>
        <div id="rematch-msg" class="rematch-status hidden">Waiting for opponent...</div>
        <button class="main-btn btn-secondary" onclick="location.reload()">MAIN MENU</button>
    </div>

    <div id="emote-container" class="hidden-ui">
        <div class="emote-picker" id="emote-picker">
            <div class="emote-item" style="background-position: 0% 0%;" onclick="sendEmote(0)"></div>
            <div class="emote-item" style="background-position: 50% 0%;" onclick="sendEmote(1)"></div>
            <div class="emote-item" style="background-position: 100% 0%;" onclick="sendEmote(2)"></div>
            <div class="emote-item" style="background-position: 0% 50%;" onclick="sendEmote(3)"></div>
            <div class="emote-item" style="background-position: 50% 50%;" onclick="sendEmote(4)"></div>
            <div class="emote-item" style="background-position: 100% 50%;" onclick="sendEmote(5)"></div>
            <div class="emote-item" style="background-position: 0% 100%;" onclick="sendEmote(6)"></div>
            <div class="emote-item" style="background-position: 50% 100%;" onclick="sendEmote(7)"></div>
            <div class="emote-item" style="background-position: 100% 100%;" onclick="sendEmote(8)"></div>
        </div>

        <div class="emote-btn-toggle" onclick="toggleEmotePicker()">
            â˜º
        </div>
    </div>
</div>


<script>
  let isCooldown = false; // Status apakah sedang dalam masa tunggu
let cooldownTime = 3;   // Durasi detik

// --- AUDIO MANAGEMENT ---
const SFX_URL = 'https://cdn.jsdelivr.net/gh/viqihakbarrr-cyber/kkk@main/FullSound.ogg';
const SFX_SPRITES = {
    deal:   { start: 0,  dur: 1 },
    flip:   { start: 2,  dur: 1 },
    play:   { start: 4,  dur: 1 },
    error:  { start: 6,  dur: 1 },
    crit:   { start: 9,  dur: 4 },
    parry:  { start: 14, dur: 2 },
    purple: { start: 19, dur: 4 },
    freezeStart: { start: 26, dur: 4 },  // Saat beku (00:26)
    freezeEnd:   { start: 175, dur: 2 }, // Saat cair (02:55 -> 175 detik)
};

const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let sfxBuffer = null;
let bgmNode = null;
let bgmGainNode = null;

async function loadAudioBuffer() {
    try {
        const response = await fetch(SFX_URL);
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const arrayBuffer = await response.arrayBuffer();
        sfxBuffer = await audioCtx.decodeAudioData(arrayBuffer);
        return true;
    } catch (e) {
        console.warn("Audio failed to load:", e);
        const detailText = document.getElementById('loading-text-detail');
        if(detailText) detailText.innerText = "AUDIO FAILED (SKIPPING...)";
        return false; 
    }
}

function playSound(type) {
    if (!sfxBuffer) return;
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const sprite = SFX_SPRITES[type];
    if (sprite) {
        const source = audioCtx.createBufferSource();
        source.buffer = sfxBuffer;
        if(type === 'parry') source.playbackRate.value = 1.5; 
        source.connect(audioCtx.destination);
        source.start(0, sprite.start, sprite.dur);
    }
}

function startBGM() {
    if (!sfxBuffer || bgmNode) return;
    if (audioCtx.state === 'suspended') audioCtx.resume();

    try {
        bgmNode = audioCtx.createBufferSource();
        bgmNode.buffer = sfxBuffer;
        
        bgmNode.loop = true;
        bgmNode.loopStart = 40; 
        bgmNode.loopEnd = 173; 

        bgmGainNode = audioCtx.createGain();
        bgmGainNode.gain.value = 1.0; 

        bgmNode.connect(bgmGainNode);
        bgmGainNode.connect(audioCtx.destination);

        bgmNode.start(0, 40);
        console.log("BGM Started");
    } catch (e) {
        console.error("BGM Error:", e);
    }
}

// --- CAROUSEL LOGIC ---
const track = document.getElementById('track');
const cards = document.querySelectorAll('.mode-card');
const container = document.getElementById('carousel-container');

let currentCardIdx = 1; // Start at Classic
const cardWidth = 270; 
let isDraggingLobby = false;
let startPos = 0;
let currentTranslate = 0;
let prevTranslate = 0;
let animationID;

function setPositionByIndex() {
    currentTranslate = (1 - currentCardIdx) * cardWidth;
    prevTranslate = currentTranslate;
    setSliderPosition();
    updateVisuals();
}

function setSliderPosition() {
    track.style.transform = `translateX(${currentTranslate}px)`;
}

function updateVisuals() {
    cards.forEach((card, index) => {
        card.classList.remove('active');
        if (index === currentCardIdx) {
            card.classList.add('active');
        }
    });
}

function animation() {
    setSliderPosition();
    if (isDraggingLobby) requestAnimationFrame(animation);
}

// --- EVENT LISTENERS (TOUCH & MOUSE) ---
container.addEventListener('touchstart', touchStart);
container.addEventListener('touchend', touchEnd);
container.addEventListener('touchmove', touchMove);

container.addEventListener('mousedown', touchStart);
container.addEventListener('mouseup', touchEnd);
container.addEventListener('mouseleave', () => { if(isDraggingLobby) touchEnd() });
container.addEventListener('mousemove', touchMove);

function touchStart(event) {
    if(isSearching) return; 
    isDraggingLobby = true;
    startPos = getPositionX(event);
    animationID = requestAnimationFrame(animation);
    track.style.transition = 'none'; 
}

function touchMove(event) {
    if (isDraggingLobby) {
        const currentPosition = getPositionX(event);
        const diff = currentPosition - startPos;
        currentTranslate = prevTranslate + diff;
    }
}

function touchEnd() {
    isDraggingLobby = false;
    cancelAnimationFrame(animationID);
    
    const movedBy = currentTranslate - prevTranslate;
    
    if (movedBy < -80 && currentCardIdx < cards.length - 1) currentCardIdx += 1;
    else if (movedBy > 80 && currentCardIdx > 0) currentCardIdx -= 1;
    
    track.style.transition = 'transform 0.3s cubic-bezier(0.25, 1, 0.5, 1)';
    setPositionByIndex();
}

function getPositionX(event) {
    return event.type.includes('mouse') ? event.pageX : event.touches[0].clientX;
}

// Click Logic
cards.forEach((card, index) => {
    card.addEventListener('click', () => {
        if(isSearching) return;

        if (index === currentCardIdx) {
            console.log("Start Matchmaking for mode index: " + index);
            startMatchmakingUI(index);
        } else {
            currentCardIdx = index;
            track.style.transition = 'transform 0.3s ease-out';
            setPositionByIndex();
        }
    });
});

setPositionByIndex();
// REPLACE bagian ASSETS_URL dengan ini:
// --- [REPLACE] UPDATE COLORS & ASSETS ---


const ASSETS_URL = {
    fire: 'https://github.com/viqihakbarrr-cyber/kkk/blob/main/BCfire.png?raw=true',
    water: 'https://github.com/viqihakbarrr-cyber/kkk/blob/main/BCwater.png?raw=true',
    leaf: 'https://github.com/viqihakbarrr-cyber/kkk/blob/main/BCleaf.png?raw=true',
    mirror: 'https://github.com/viqihakbarrr-cyber/kkk/blob/main/SCmiror.png?raw=true',
    purple: 'https://github.com/viqihakbarrr-cyber/kkk/blob/main/SCpurple.png?raw=true',
    blind: 'https://github.com/viqihakbarrr-cyber/kkk/blob/main/FXblind.png?raw=true', 
    back: 'https://github.com/viqihakbarrr-cyber/kkk/blob/main/Back.png?raw=true',
    emotes: 'https://raw.githubusercontent.com/viqihakbarrr-cyber/CATALYST/main/emot.png',
    // NEW ASSETS
    freeze: 'https://github.com/viqihakbarrr-cyber/kkk/blob/main/SCfreze.png?raw=true',
    ice: 'https://github.com/viqihakbarrr-cyber/kkk/blob/main/FXice.png?raw=true'
};



const IMAGES = {};
let assetsLoaded = false;


// --- EMOTE FUNCTIONS ---

function toggleEmotePicker() {
    const picker = document.getElementById('emote-picker');
    picker.classList.toggle('active');
}

function sendEmote(index) {
    // 1. Tutup Picker
    document.getElementById('emote-picker').classList.remove('active');

    // 2. Tampilkan di sisi kita
    triggerEmoteDisplay(true, index);

    // 3. Kirim ke lawan via Network
    if (conn && conn.open) {
        conn.send({ type: 'EMOTE', index: index });
    }
}

function triggerEmoteDisplay(isMe, index) {
    if (isMe) {
        activeEmote.me.id = index;
        activeEmote.me.timer = EMOTE_DURATION;
    } else {
        activeEmote.opp.id = index;
        activeEmote.opp.timer = EMOTE_DURATION;
    }
    playSound('play'); // Opsional: Bunyi saat kirim emot
}

// Fungsi helper untuk menggambar sprite sheet 3x3
function drawEmoteSprite(ctx, index, x, y, size) {
    if (!IMAGES.emotes) return;
    
    // Logika Sprite Sheet 3x3
    // Kolom = index % 3
    // Baris = Math.floor(index / 3)
    let col = index % 3;
    let row = Math.floor(index / 3);
    
    // Ukuran per frame di gambar asli (asumsi gambar dibagi rata 3x3)
    let spriteW = IMAGES.emotes.width / 3;
    let spriteH = IMAGES.emotes.height / 3;

    ctx.drawImage(
        IMAGES.emotes,          // Source Image
        col * spriteW,          // Source X
        row * spriteH,          // Source Y
        spriteW,                // Source Width
        spriteH,                // Source Height
        x - size / 2,           // Destination X (Center)
        y - size / 2,           // Destination Y (Center)
        size,                   // Dest Width
        size                    // Dest Height
    );
}



function loadAssets() {
    const imgKeys = Object.keys(ASSETS_URL);
    const totalAssets = imgKeys.length + 1; // +1 untuk Audio
    let loadedCount = 0;
    
    const barFill = document.getElementById('loading-bar-fill');
    const textDetail = document.getElementById('loading-text-detail');

    function updateLoadingUI(itemName) {
        loadedCount++;
        const percent = Math.floor((loadedCount / totalAssets) * 100);
        
        if(barFill) barFill.style.width = `${percent}%`;
        if(textDetail) textDetail.innerText = `SYSTEM LOAD... ${itemName} (${percent}%)`;
        
        if (loadedCount >= totalAssets) {
            // Beri jeda sedikit saat 100% sebelum masuk lobby
            setTimeout(onAllAssetsLoaded, 800);
        }
    }

    // Load Gambar
    imgKeys.forEach(key => {
        const img = new Image();
        img.src = ASSETS_URL[key];
        img.onload = () => { IMAGES[key] = img; updateLoadingUI(key.toUpperCase()); };
        img.onerror = () => { IMAGES[key] = null; updateLoadingUI(key.toUpperCase() + " (SKIP)"); };
    });

    // Load Audio
    loadAudioBuffer().then(() => {
        updateLoadingUI("AUDIO CORE");
    });
}


// Fungsi untuk mematikan efek blind dan merapikan kartu
function endBlindMode() {
    isBlinded = false;
    blindTurnsLeft = 0;
    
    // Kembalikan timeScale ke normal (jika ada efek slow mo sisa)
    timeScale = 1.0; 
    
    // --- Ungkap semua placeholder blind di TANGAN SAYA ---
    myHand.forEach(c => {
        // Reset fisika agar kartu kembali rapi
        c.angle = 0;
        c.vx = 0;
        c.vy = 0;
        c.rotSpeed = 0;

        if (c.isBlindPlaceholder) {
            // Restore nilai asli
            c.suit = c.realSuit || c.suit;
            c.value = c.realValue || c.value;
            
            // Hapus flag
            c.isBlindPlaceholder = false;

            // Animasi flip reveal
            c.isFaceUp = false;    
            c.scaleX = 1;          
            c.startFlip();         
        }
    });

    // Rapikan posisi kartu di tangan
    rearrangeHand();
    playSound('deal');
}

// --- FUNGSI TRANSISI BARU (Sesuai Request) ---
function onAllAssetsLoaded() {
  assetsLoaded = true;
    console.log("All assets loaded. Starting transitions...");
    
 // document.body.style.backgroundImage = "url('https://github.com/viqihakbarrr-cyber/kkk/blob/main/BG.png?raw=true')";
    
    // 1. Ambil elemen
    const loadingLayer = document.getElementById('loading-layer');
    const lobbyScreen = document.getElementById('lobby-screen');
    const carousel = document.getElementById('carousel-container');

    // 2. Tampilkan Lobby (di belakang loading layer yang masih hitam)
    if(lobbyScreen) {
        lobbyScreen.classList.remove('hidden');
        if(typeof setPositionByIndex === 'function') setPositionByIndex();
    }

    // 3. Fade Out Loading Layer (Splash + Hitam)
    // Ini akan menciptakan efek "Mix Smooth" karena Lobby Screen sudah ada di bawahnya
    if(loadingLayer) {
        loadingLayer.style.opacity = "0"; 
        
        // Hapus elemen loading dari DOM/Layout setelah transisi opacity selesai
        setTimeout(() => {
            loadingLayer.classList.add('hidden');
        }, 1500); // Sesuai durasi CSS transition (1.5s)
    }

    // 4. Jalankan Animasi Kartu Turun dari Atas
    if(carousel) {
        // Reset posisi dulu untuk jaga-jaga
        carousel.style.opacity = "0"; 
        
        // Tambahkan class animasi CSS yang sudah kita buat
        // Delay sedikit (200ms) agar barengan dengan fade out background
        setTimeout(() => {
            carousel.classList.add('drop-in-animation');
            // Pastikan opacity jadi 1 karena dikontrol keyframes
            carousel.style.opacity = "1"; 
        }, 200);
    }
}
// --- MATCHMAKING ANIMATION LOGIC ---
let searchTimerInterval = null;
let searchSeconds = 0;
let animTimeout1, animTimeout2; 
let lastSearchStartTime = 0; // Tambahkan variabel global ini


function startMatchmakingUI(modeIndex) {
    // 1. Cek Cooldown
    if (isCooldown) {
        showLobbyToast("Try again in a few seconds");
        return; 
    }

    if (isSearching) return;
    lastSearchStartTime = Date.now(); 

    startBGM(); 
    isSearching = true;
    
    // Matikan interaksi geser kartu
    document.getElementById('track').style.pointerEvents = 'none';
    
    // --- UPDATE: Sembunyikan kartu yang tidak dipilih ---
    cards.forEach((card, index) => {
        if (index !== modeIndex) {
            card.classList.add('faded-out'); // Hilangkan kartu lain
        }
    });

    const activeCard = cards[modeIndex];
    
    // --- ANIMASI KARTU ---
    // Step 1: Kartu Berputar (Hapus efek tilt 3D dulu biar putarannya bagus)
    activeCard.style.transform = "scale(1.05) rotate(0deg)"; // Reset tilt manual sebelum putar
    setTimeout(() => {
        activeCard.classList.add('anim-rotate');
        playSound('play');
    }, 50);

    // Step 2: Kartu Terbang ke Atas (Gelap)
    animTimeout1 = setTimeout(() => {
        activeCard.classList.add('anim-searching');
    }, 600);

    // --- ANIMASI UI MATCHMAKING ---
    animTimeout2 = setTimeout(() => {
        const uiContainer = document.getElementById('matchmaking-ui');
        const label = document.getElementById('mm-label');
        
        uiContainer.classList.remove('hidden');
        uiContainer.classList.remove('active-cancel');
        
        if(modeIndex === 0) label.innerText = "SEARCHING RANKED...";
        else if(modeIndex === 2) label.innerText = "CONNECTING FRIEND...";
        else label.innerText = "FINDING MATCH";
        
        searchSeconds = 0;
        updateTimerDisplay(searchSeconds);
        
        if(searchTimerInterval) clearInterval(searchTimerInterval);
        searchTimerInterval = setInterval(() => {
            searchSeconds++;
            updateTimerDisplay(searchSeconds);
        }, 1000);

        uiContainer.classList.add('active-cancel');

        initializeSocketLogic(); 
    }, 1200);
}



function initializeSocketLogic() {
    if (typeof io === 'undefined') {
        const script = document.createElement('script');
        script.src = 'https://cdn.socket.io/4.7.2/socket.io.min.js';
        script.onload = () => initializeSocket(); 
        script.onerror = () => {
             cancelMatchmaking();
             showFloatingText("CONNECTION FAILED", width/2, height/2, "red");
        };
        document.head.appendChild(script);
    } else {
        initializeSocket();
    }
}

function checkWinCondition() {
    // 1. Cek apakah game sedang berjalan
    if (gameState !== 'PLAYING') return;
    
    // 2. Cek apakah kartu sudah pernah dibagikan (PENTING AGAR TIDAK WIN DI AWAL)
    if (!cardsDealt) return; 

    // 3. Logika Menang (Kartu kita habis)
    if (myHand.length === 0) {
        if (conn && conn.open) conn.send({ type: 'GAME_OVER_SYNC', winner: 'opponent' });
        endGame("YOU WIN!", "Victory Achieved", true);
    } 
    // 4. Logika Kalah (Kartu lawan habis)
    else if (opponentHand.length === 0) {
        endGame("GAME OVER", "Opponent finished their cards", false);
    }
}



function cancelMatchmaking(e) {
    if(e) e.stopPropagation();

    // Proteksi 3 detik
    const currentTime = Date.now();
    if (currentTime - lastSearchStartTime < 3000) return; 

    // Cooldown Logic
    isCooldown = true;
    cooldownTime = 3; 
    const cdInterval = setInterval(() => {
        cooldownTime--;
        if (cooldownTime <= 0) {
            clearInterval(cdInterval);
            isCooldown = false;
        }
    }, 1000);

    // --- SEMBUNYIKAN UI MATCHMAKING ---
    const uiContainer = document.getElementById('matchmaking-ui');
    if(uiContainer) {
        uiContainer.classList.remove('active-cancel'); // Hilangkan tombol dulu
        uiContainer.classList.add('hidden'); // Hilangkan container
    }

    // --- KEMBALIKAN ANIMASI KARTU ---
    const activeCard = document.querySelector('.mode-card.anim-rotate');
    if(activeCard) {
        activeCard.classList.remove('anim-searching'); // Turun
        setTimeout(() => {
            activeCard.classList.remove('anim-rotate'); // Balik putaran
            resetLobbyState(); 
        }, 600);
    } else {
        resetLobbyState();
    }
}

function resetLobbyState() {

    document.body.style.backgroundImage = "none";
    document.body.style.backgroundColor = "#000";
  
    if (socket) { socket.disconnect(); socket = null; }
    if (peer) { peer.destroy(); peer = null; }
    conn = null;
    isSearching = false;
    isHost = false;
    
    // Bersihkan interval
    if(searchTimerInterval) { clearInterval(searchTimerInterval); searchTimerInterval = null; }

    const track = document.getElementById('track');
    if(track) track.style.pointerEvents = 'auto';

    // Reset semua kartu
    cards.forEach(c => {
        c.classList.remove('anim-searching');
        c.classList.remove('anim-rotate');
        c.classList.remove('faded-out');
        c.style.transform = ""; 
    });
    
    // Pastikan UI Matchmaking hilang
    document.getElementById('matchmaking-ui').classList.add('hidden');
    
    document.getElementById('lobby-screen').classList.remove('hidden');
    document.getElementById('loading-layer').classList.add('hidden'); 

    // [BARU] Sembunyikan UI Emote saat kembali ke lobby
    const emoteContainer = document.getElementById('emote-container');
    if(emoteContainer) emoteContainer.classList.add('hidden-ui');
    
    // Panggil ulang posisi visual agar kartu active kembali ke efek 3D
    updateVisuals(); 

    if (matchmakingTimeout) { clearTimeout(matchmakingTimeout); matchmakingTimeout = null; }
}



let resetLobby = resetLobbyState; 

function updateTimerDisplay(seconds) {
    const min = Math.floor(seconds / 60).toString().padStart(2, '0');
    const sec = (seconds % 60).toString().padStart(2, '0');
    
    // Target ke elemen global baru
    const el = document.getElementById('mm-timer');
    if(el) el.innerText = `${min}:${sec}`;
}

function showConnectingUI() {
    // Ubah text label global
    const label = document.getElementById('mm-label');
    if(label) {
        label.innerText = "OPPONENT FOUND!";
        label.style.color = "#00FF00";
    }
    
    if(searchTimerInterval) clearInterval(searchTimerInterval);
}

// Fungsi khusus untuk menampilkan pesan di atas Lobby
function showLobbyToast(text) {
    const el = document.createElement('div');
    el.innerText = text;
    
    // Style agar terlihat di tengah layar & di atas Lobby
    el.style.position = 'absolute';
    el.style.top = '50%';
    el.style.left = '50%';
    el.style.transform = 'translate(-50%, -50%)';
    el.style.color = '#FF4444'; // Merah terang
    el.style.fontFamily = "'Orbitron', sans-serif";
    el.style.fontSize = '11px';
    el.style.fontWeight = 'bold';
    el.style.textShadow = '0 0 10px #000, 0 0 20px #FF0000'; // Efek glow
    el.style.zIndex = '9999'; // Pastikan paling atas
    el.style.pointerEvents = 'none'; // Agar tidak mengganggu klik
    el.style.opacity = '1';
    el.style.transition = 'all 1s ease-out';

    document.body.appendChild(el);

    // Animasi menghilang (Fade out & Float up)
    requestAnimationFrame(() => {
        setTimeout(() => {
            el.style.opacity = '0';
            el.style.top = '40%'; // Gerak sedikit ke atas
        }, 100);
    });

    // Hapus elemen setelah animasi selesai
    setTimeout(() => {
        if (el.parentNode) el.parentNode.removeChild(el);
    }, 1100);
}

// --- GAME VARIABLES & SOCKET ---
let peer = null;
let conn = null;
let myPeerID = null;
let isHost = false;
let rematchMe = false;
let rematchOpp = false;
let canParry = false; 
let parryActive = false; 

const BROKER_URL = "https://beagle-causal-gorilla.ngrok-free.app"; 
let socket = null;
let isSearching = false;
let matchmakingTimeout = null;

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let width, height;
let particles = [];
let floatingTexts = [];
let projectiles = [];

const CARD_RATIO = 2.5 / 4.0;
let cardScale = 1;
let cardW = 100;
let cardH = 160;

const SUITS = ['fire', 'water', 'leaf', 'mirror'];
const BASIC_SUITS = ['fire', 'water', 'leaf'];
const COLORS = { 
    fire: '#FF2222', 
    water: '#0088FF', 
    leaf: '#00CC44', 
    mirror: '#00FFFF', 
    purple: '#800080',
    freeze: '#00E5FF' // Warna Cyan untuk efek Freeze
};
const COUNTER_MAP = { fire: 'leaf', leaf: 'water', water: 'fire' };

let graphicsQuality = 'high'; // 'low', 'medium', 'high'

let deck = [];
let discardPile = [];
let myHand = [];
let opponentHand = []; 
let turn = ''; 
let gameState = 'MENU'; 
let isAnimating = false; 
let isBlinded = false;    
let blindTurnsLeft = 0
let selectedIdx = -1;
let dragIdx = -1;
let dragOffsetX = 0;
let dragOffsetY = 0;
let cardsDealt = false; // Penanda apakah kartu sudah dibagikan
let timeScale = 1.0
let slowMoActive = false; // Add this with other globals
// --- EMOTE VARIABLES ---
let activeEmote = { 
    me: { id: -1, timer: 0 }, 
    opp: { id: -1, timer: 0 } 
};
const EMOTE_DURATION = 150; // Durasi tampil (dalam frame update, sekitar 2.5 detik)


document.addEventListener('fullscreenchange', () => {
    const btn = document.getElementById('fs-toggle');
    btn.style.display = document.fullscreenElement ? 'none' : 'flex'; 
});
function toggleFullscreen() {
    if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(err => console.log(err));
    }
}





function easeInOutCubic(x) {
    return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2;
}
// --- [REPLACE] UPDATE CLASS CARD ---
class Card {
    constructor(suit, value, isMine = true) {
        this.suit = suit; this.value = value;
        this.isMine = isMine;
        this.id = Math.random().toString(36).substr(2, 9);
        this.x = 60; this.y = height/2 + 30; 
        
        this.startX = this.x; this.startY = this.y;
        this.targetX = width / 2; this.targetY = height / 2;
        this.animStartTime = 0;
        this.animDuration = 0;
        this.isAnimatingPos = false;

        this.shake = 0;
        this.isHovered = false;
        this.isSelected = false; 
        this.isDragging = false; 

        this.isFaceUp = isMine; 
        this.scaleX = 1;      
        this.flipping = false;
        
        // --- NEW PROPERTIES FOR FREEZE ---
        this.isFrozen = false; 
        this.freezeTimer = 0; 

        this.angle = 0; 
        this.initPhysics(); 
    }

    initPhysics() {
        this.vx = (Math.random() - 0.5) * 5; 
        this.vy = (Math.random() - 0.5) * 5; 
        this.rotSpeed = (Math.random() - 0.5) * 0.15; 
    }

    updateFloating(boundsY) {
        if (this.isDragging || this.isAnimatingPos) {
            this.angle = 0; 
            return;
        }
        this.x += this.vx;
        this.y += this.vy;
        this.angle += this.rotSpeed;

        if (this.x < 50) { this.x = 50; this.vx *= -1; }
        if (this.x > width - 50) { this.x = width - 50; this.vx *= -1; }
        if (this.y < boundsY) { this.y = boundsY; this.vy *= -1; }
        if (this.y > height - 60) { this.y = height - 60; this.vy *= -1; }
    }

    draw(ctx, forceFaceUp, x, y, w, h) {
        let drawW = w || cardW;
        let drawH = h || cardH;

        if (this.isDragging) {
            this.x = x; this.y = y;
            this.isAnimatingPos = false; 
        } else if (this.isAnimatingPos) {
            let elapsed = performance.now() - this.animStartTime;
            let progress = Math.min(elapsed / this.animDuration, 1);
            let ease = easeInOutCubic(progress);
            this.x = this.startX + (this.targetX - this.startX) * ease;
            this.y = this.startY + (this.targetY - this.startY) * ease;
            if (progress >= 1) this.isAnimatingPos = false;
        } else {
            if (!isBlinded || !this.isMine || forceFaceUp !== undefined) { 
                this.x += (this.targetX - this.x) * 0.15;
                this.y += (this.targetY - this.y) * 0.15;
                if (!isBlinded) this.angle = 0; 
            }
        }

        if (this.isMine && !this.isFaceUp && !this.flipping && Math.abs(this.x - this.targetX) < 10) {
            this.startFlip();
        }
        if (this.flipping) {
            if (!this.isFaceUp) {
                this.scaleX -= 0.15;
                if (this.scaleX <= 0) { this.scaleX = 0; this.isFaceUp = true; playSound('flip'); }
            } else {
                this.scaleX += 0.15;
                if (this.scaleX >= 1) { this.scaleX = 1; this.flipping = false; }
            }
        }

        let offsetX = 0; if (this.shake > 0) { offsetX = Math.sin(Date.now() * 0.5) * 5; this.shake -= 1; }

        ctx.save();
        ctx.translate(this.x + offsetX, this.y);
        
        if(isBlinded && this.isMine && !forceFaceUp && !this.isDragging) {
            ctx.rotate(this.angle);
        }

        let s = 1.0;
        if(this.isSelected) s = 1.1;
        if(this.isDragging) s = 1.15;
        ctx.scale(s * this.scaleX, s);

        let showFace = (forceFaceUp !== undefined) ? forceFaceUp : this.isFaceUp;

        if (showFace) {
            let assetKey = this.suit;
            
            // Logic: Blind menutup kartu, tapi Freeze overlay di atasnya
            if (isBlinded) assetKey = 'blind'; 

            if (assetKey === 'blind') { ctx.shadowColor = COLORS.purple; ctx.shadowBlur = 15; } 
            else if (this.isFrozen) { ctx.shadowColor = COLORS.freeze; ctx.shadowBlur = 15; } // Shadow Biru Es
            else { ctx.shadowColor = 'rgba(0,0,0,0.5)'; ctx.shadowBlur = (this.isSelected || this.isDragging) ? 25 : 5; }
            
            ctx.shadowOffsetY = (this.isSelected || this.isDragging) ? 15 : 5;

            // 1. Gambar Base Card
            if (IMAGES[assetKey]) {
                ctx.drawImage(IMAGES[assetKey], -drawW/2, -drawH/2, drawW, drawH);
            } else {
                ctx.fillStyle = '#fff'; ctx.fillRect(-drawW/2, -drawH/2, drawW, drawH);
            }
            
            // 2. Gambar Angka (Jika bukan blind/special)
            if (assetKey !== 'blind' && this.suit !== 'mirror' && this.suit !== 'purple' && this.suit !== 'freeze') {
                ctx.shadowBlur = 0; ctx.shadowOffsetY = 0;
                ctx.fillStyle = "#FFFFFF"; ctx.strokeStyle = "#000000"; ctx.lineWidth = 2; 
                let fontSize = drawW * 0.18; 
                ctx.font = `700 ${fontSize}px 'Cinzel', serif`;
                let padX = drawW * 0.12; let padY = drawH * 0.1;
                ctx.textAlign = 'left'; ctx.textBaseline = 'top';
                ctx.strokeText(this.value, -drawW/2 + padX, -drawH/2 + padY);
                ctx.fillText(this.value, -drawW/2 + padX, -drawH/2 + padY);
                ctx.textAlign = 'right'; ctx.textBaseline = 'bottom';
                ctx.strokeText(this.value, drawW/2 - padX, drawH/2 - padY);
                ctx.fillText(this.value, drawW/2 - padX, drawH/2 - padY);
            }

            // 3. GAMBAR OVERLAY ICE (JIKA BEKU)
            // Sesuai request: Layer paling atas, tapi hilang visualnya jika terkena Blind (Mata Ungu)
            // Logika: Jika Blind, visualnya jadi mata (di-handle di assetKey). Jika TIDAK Blind tapi Frozen, gambar es.
            if (this.isFrozen && !isBlinded && IMAGES.ice) {
                // Gambar efek es sedikit lebih besar dari kartu
                let iceScale = 1.1; 
                ctx.drawImage(IMAGES.ice, (-drawW/2)*iceScale, (-drawH/2)*iceScale, drawW*iceScale, drawH*iceScale);
            }

        } else {
            // Bagian Belakang
            ctx.shadowColor = 'rgba(0,0,0,0.5)'; ctx.shadowBlur = 5;
            if(IMAGES.back) ctx.drawImage(IMAGES.back, -drawW/2, -drawH/2, drawW, drawH);
            else { ctx.fillStyle = '#333'; ctx.fillRect(-drawW/2, -drawH/2, drawW, drawH); }
        }
        ctx.restore();
    }

    startFlip() { this.flipping = true; }
}


// --- NEW CINEMATIC PROJECTILE CLASS ---
class ProjectileCard {
    constructor(targetIsMe, delayOffset = 0) {
        // 1. Muncul dari DECK (Kiri Tengah)
        this.x = 60; 
        this.y = height / 2 + 30;
        
        this.targetIsMe = targetIsMe; // True = Nyerang Kita, False = Nyerang Lawan
        this.startTime = Date.now() + delayOffset; // Delay sedikit biar 2 kartu tidak numpuk total
        
        // State: 0=Menuju Tengah, 1=SlowMo/ParryWindow, 2=Menuju Korban
        this.phase = 0; 
        
        this.phaseStart = this.startTime;
        this.isDead = false;
        this.angle = 0;
        
        // Visual
        this.rotationSpeed = 15; // Berputar cepat saat terbang
    }

    update() {
        let now = Date.now();
        if (now < this.startTime) return; // Tunggu delay offset

        let elapsed = now - this.phaseStart;

        // --- PHASE 1: DECK KE TENGAH (Durasi 1.5 Detik) ---
        if (this.phase === 0) {
            let duration = 1500; 
            let t = Math.min(elapsed / duration, 1);
            
            // Ease Out Cubic agar melambat saat sampai tengah
            let ease = 1 - Math.pow(1 - t, 3); 

            let startX = 60;
            let startY = height / 2 + 30;
            let targetX = width / 2;
            let targetY = height / 2;

            this.x = startX + (targetX - startX) * ease;
            this.y = startY + (targetY - startY) * ease;
            this.angle += 0.2; // Putaran visual

            if (t >= 1) {
                this.phase = 1; // Masuk fase Slow Motion
                this.phaseStart = now;
                
                // TRIGGER GLOBAL SLOW MOTION & PARRY
                if (this.targetIsMe) {
                    // Hanya aktifkan parry jika ini serangan ke kita
                    canParry = true;
                    slowMoActive = true; 
                    showFloatingText("!!! PARRY NOW !!!", width/2, height/2 - 80, "#FF0000");
                }
            }
        }

        // --- PHASE 2: SLOW MOTION DI TENGAH (Durasi 1.5 Detik) ---
        else if (this.phase === 1) {
            let duration = 1500;
            
            // Kartu berputar pelan sekali (efek dramatis)
            this.angle += 0.02; 
            
            // Sedikit mengambang (Floating effect)
            this.y = (height / 2) + Math.sin(elapsed * 0.005) * 10;

            // Jika waktu habis, dan belum di-Parry -> Lanjut Hantam
            if (elapsed >= duration) {
                this.phase = 2;
                this.phaseStart = now;
                
                // Matikan Slow Mo
                slowMoActive = false;
                canParry = false;
                timeScale = 1.0;
            }
        }

        // --- PHASE 3: HANTAM TARGET (Cepat) ---
        else if (this.phase === 2) {
            // Target tergantung siapa yang kena (Kita atau Lawan)
            let targetY = this.targetIsMe ? height + 100 : -100;
            let speed = 25; // Kecepatan hantam

            // Gerak Vertikal Lurus ke target
            if (this.targetIsMe) this.y += speed;
            else this.y -= speed;
            
            this.angle += 0.5; // Putar gila-gilaan saat nyerang

            // --- DETEKSI TABRAKAN (HIT) ---
            if (this.targetIsMe && this.y > height - 50) {
                this.handleImpact(true); // Kena Kita
            } else if (!this.targetIsMe && this.y < 50) {
                this.handleImpact(false); // Kena Lawan (Makan Tuan atau Serangan Kita)
            }
        }
    }

    handleImpact(hitMe) {
        this.isDead = true;
        spawnExplosion(this.x, this.y, hitMe ? '#FF0000' : '#FFAA00');
        playSound('crit'); // Suara ledakan

        if (hitMe) {
            // --- LOGIKA HUKUMAN: TERIMA KARTU ---
            // Konversi Projectile menjadi Kartu Asli di Tangan
            let penaltyCard = drawCardFromDeckLogic(); // Ambil kartu random
            if(penaltyCard) {
                penaltyCard.x = this.x; // Posisi mulai dari posisi ledakan projectile
                penaltyCard.y = this.y;
                penaltyCard.isFaceUp = true; // Langsung terbuka (reveal)
                penaltyCard.shake = 20; // Efek getar
                
                
                
                if (isBlinded) {
        // Jika sedang blind: jadikan placeholder blind, jangan reveal nilai asli
        penaltyCard.realSuit = penaltyCard.suit;
        penaltyCard.realValue = penaltyCard.value;
        penaltyCard.isBlindPlaceholder = true;
        penaltyCard.isFaceUp = false; // belum mengungkap nilai asli
        penaltyCard.initPhysics();    // agar mengambang
        penaltyCard.startFlip();      // flip ke visual blind sekarang
    } else {
        // normal: reveal langsung
        penaltyCard.isFaceUp = true;
    }

    myHand.push(penaltyCard);

    // Rapikan tangan hanya jika tidak blind (agar kartu baru mencari slotnya)
    if (!isBlinded) rearrangeHand();
}
              
            
            showFloatingText("CRITICAL HIT! (+1)", width/2, height/2, "red");
            startScreenShake(); // Efek layar getar
            
            // Sync ke server kalau kita kena (opsional, untuk visual lawan)
            if (conn && conn.open) conn.send({ type: 'PENALTY_SYNC' }); 

        } else {
            // Kena Lawan
            showFloatingText("ENEMY HIT!", width/2, 100, "yellow");
        }
    }

    // Fungsi dipanggil saat tombol Mirror ditekan
    parry() {
        if (this.phase === 1 && this.targetIsMe) {
            this.targetIsMe = false; // Balikkan arah ke lawan!
            this.phase = 2; // Langsung masuk fase serang (skip sisa slow mo)
            this.phaseStart = Date.now(); // Reset timer animasi gerak
            
            // Visual Feedback
            spawnExplosion(this.x, this.y, '#00FFFF'); // Ledakan biru mirror
        }
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        
        // Z-Index Visual: Shadow tebal agar terlihat melayang tinggi
        ctx.shadowColor = "rgba(0,0,0,0.8)";
        ctx.shadowBlur = 30; 
        ctx.shadowOffsetY = 20;

        // Glow sesuai target (Merah=Bahaya/Ke Kita, Emas=Ke Lawan/Kita Nyerang)
        if (this.phase === 1) { // Saat Slow Mo
             ctx.strokeStyle = this.targetIsMe ? "#FF0000" : "#00FFFF";
             ctx.lineWidth = 5;
             ctx.strokeRect(-cardW/2, -cardH/2, cardW, cardH);
        }

        if(IMAGES.back) {
            ctx.drawImage(IMAGES.back, -cardW/2, -cardH/2, cardW, cardH);
        } else {
            ctx.fillStyle = '#FF4444'; 
            ctx.fillRect(-cardW/2, -cardH/2, cardW, cardH);
        }
        ctx.restore();
    }
}


class Particle {
    constructor(x, y, color, isExplosion) {
        this.x = x; this.y = y; this.color = color;
        this.size = Math.random() * 5 + 2;
        let speed = isExplosion ? 15 : 10;
        this.vx = (Math.random() - 0.5) * speed;
        this.vy = (Math.random() - 0.5) * speed;
        this.life = 1;
    }
    update() {
        this.x += this.vx; this.y += this.vy;
        this.life -= 0.02; this.size *= 0.95;
    }
    draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill(); ctx.globalAlpha = 1;
    }
}

// --- SOCKET LOGIC ---
function initializeSocket() {
    try {
        socket = io(BROKER_URL, {
            transports: ['websocket', 'polling'],
            reconnection: false,
            timeout: 10000
        });

        socket.on('connect', () => {
            console.log('Connected to matchmaking server');
            document.getElementById('search-status').innerText = 'Connected. Generating Peer ID...';
            createPeerForMatchmaking();
        });

        socket.on('connect_error', (error) => {
            console.error('Socket connection error:', error);
            document.getElementById('search-status').innerText = 'Failed to connect to matchmaking server.';
            isSearching = false;
            setTimeout(() => resetLobby(), 3000);
        });

        socket.on('match_found', (data) => {
            console.log('Match found:', data);
            handleMatchFound(data);
        });

        socket.on('queue_update', (data) => {
            document.getElementById('search-status').innerText = data.message;
            if (data.position > 1) {
                document.getElementById('queue-position').innerText = `Position in queue: ${data.position}`;
            }
        });

        socket.on('timeout', (data) => {
            document.getElementById('search-status').innerText = data.message;
            isSearching = false;
            setTimeout(() => resetLobby(), 3000);
        });

        socket.on('error', (data) => {
            document.getElementById('search-status').innerText = data.message || 'Server error occurred.';
            isSearching = false;
            setTimeout(() => resetLobby(), 3000);
        });

        socket.on('disconnect', (reason) => {
            if (isSearching) {
                document.getElementById('search-status').innerText = 'Disconnected from server.';
                isSearching = false;
                setTimeout(() => resetLobby(), 2000);
            }
        });

    } catch (error) {
        console.error('Failed to initialize socket:', error);
        document.getElementById('search-status').innerText = 'Failed to initialize connection.';
        isSearching = false;
        setTimeout(() => resetLobby(), 3000);
    }
}

function createPeerForMatchmaking() {
    if (peer) peer.destroy();
    peer = new Peer(undefined, { debug: 1 });

    peer.on('open', (id) => {
        myPeerID = id;
        document.getElementById('search-status').innerText = 'Peer ID generated. Joining queue...';
        if (socket && socket.connected) {
            socket.emit('join_queue', { peerId: myPeerID });
        }
    });

    peer.on('connection', (c) => {
        conn = c;
        setupConnection();
        if (conn.open) handleConnectionReady();
        else conn.on('open', handleConnectionReady);
    });

    peer.on('error', (err) => {
        if (isSearching) {
            document.getElementById('search-status').innerText = 'PeerJS error: ' + err.type;
            isSearching = false;
            setTimeout(() => resetLobby(), 3000);
        }
    });
}

function handleMatchFound(data) {
    isHost = data.role === 'host';
    const targetPeerId = data.opponentId;
    showConnectingUI();

    if (isHost) {
        conn = peer.connect(targetPeerId, { reliable: true });
        setupConnection();
        conn.on('open', handleConnectionReady);
        conn.on('error', (err) => {
            document.getElementById('connecting-status').innerText = 'Connection failed. Please try again.';
            setTimeout(() => resetLobby(), 3000);
        });
    } else {
        document.getElementById('connecting-status').innerText = 'Waiting for host connection...';
        matchmakingTimeout = setTimeout(() => {
            if (!conn || !conn.open) {
                document.getElementById('connecting-status').innerText = 'Connection timeout.';
                setTimeout(() => resetLobby(), 2000);
            }
        }, 15000);
    }
}



function setupConnection() {
    if (!conn) return;
    conn.on('open', () => { console.log("P2P connection established"); });
    conn.on('data', (data) => { handleNetworkData(data); });
    
    conn.on('close', () => { 
        if(gameState !== 'GAMEOVER' && gameState !== 'MENU') {
            endGame("DISCONNECTED", "Opponent left the game"); 
        }
    });
    conn.on('error', (err) => {
        if (gameState === 'PLAYING') endGame("ERROR", "Connection error occurred");
    });
}

    function handleConnectionReady() {
    console.log('Connection ready - starting game');
    
    // PASANG BACKGROUND DI SINI (Saat Match Found / Siap Main)
    document.body.style.backgroundImage = "url('https://github.com/viqihakbarrr-cyber/kkk/blob/main/BG.png?raw=true')";
    document.body.style.backgroundSize = "cover";
    document.body.style.backgroundPosition = "center";

    if (matchmakingTimeout) { clearTimeout(matchmakingTimeout); matchmakingTimeout = null; }

    document.getElementById('lobby-screen').classList.add('hidden');
    if (socket && socket.connected) socket.emit('leave_queue');
    if (isHost) startMultiplayerGame();
}

function handleNetworkData(data) {
    if (data.type === 'START_GAME') {
        // 1. Reset Variabel & UI
        resetGameVars();
        document.getElementById('lobby-screen').classList.add('hidden');
        document.getElementById('game-over').style.display = 'none';
        
        // Sembunyikan Loading Layer jika masih ada
        document.getElementById('loading-layer').classList.add('hidden');

        // [BARU] Munculkan tombol emote saat game mulai
        const emoteContainer = document.getElementById('emote-container');
        if(emoteContainer) emoteContainer.classList.remove('hidden-ui');

        // [PENTING] Tampilkan Canvas & Resize agar koordinat benar
        const cvs = document.getElementById('gameCanvas');
        cvs.style.display = 'block';
        resize(); 

        // 2. Set Status Game & Giliran
        gameState = 'PLAYING';
        turn = data.turn === 'p2' ? 'me' : 'opponent';

        // 3. Generate Objek Kartu dari Data yang Diterima
        let myStartCards = data.p2Hand.map(c => new Card(c.suit, c.value, true));
        
        // Buat objek kartu untuk Top Card (kartu di tengah)
        let topCardObj = new Card(data.topDiscard.suit, data.topDiscard.value, true);

        // 4. Jalankan Animasi Pembagian Kartu
        playDealAnimation(myStartCards, data.p1HandCount, topCardObj);
    
    } else if (data.type === 'OPPONENT_MOVE') {
        // Menangani saat lawan mengeluarkan kartu
        processOpponentMove(data.card, data.isCrit, data.effect);
    
    } else if (data.type === 'OPPONENT_DRAW') {
        // Menangani saat lawan mengambil kartu dari deck
        addCardToOpponentHand();
        turn = 'me';
        showFloatingText("YOUR TURN", width/2, height/2 + 100, "#0f0");
        
    } else if (data.type === 'PARRY_SUCCESS') {
        showFloatingText("PARRIED!", width/2, height/2, COLORS.mirror);
        playSound('parry');
        projectiles = []; 
        spawnProjectiles(true, false); 
        
        if (opponentHand.length > 0) {
            opponentHand.pop(); 
            rearrangeOpponentHand();
        }
        let mirrorCard = new Card('mirror', 0, false);
        mirrorCard.x = width/2; mirrorCard.y = -100;
        mirrorCard.targetX = width/2; mirrorCard.targetY = height/2;
        discardPile.push(mirrorCard);
        
    } else if (data.type === 'BLIND_END') {
        // Lawan memberi tahu bahwa blind mereka sudah habis
        // Kita bisa menampilkan efek visual atau sekadar log
        console.log("Opponent is no longer blinded");
        
        // Opsional: Jika Anda punya indikator UI bahwa musuh sedang buta, matikan di sini.
    

    } else if (data.type === 'GAME_OVER_SYNC') {
        // Jika menerima sinyal ini, berarti lawan menang, maka kita kalah
        endGame("GAME OVER", "Opponent won the match", false);
      
    } else if (data.type === 'REQUEST_REMATCH') {
        rematchOpp = true;
        showFloatingText("Opponent wants rematch!", width/2, height/2, "#fff");
        checkRematchStart();
        
    } else if (data.type === 'PENALTY_SYNC') {
        // Jika lawan kena projectile, tambah kartu visual di tangan mereka
        addCardToOpponentHand(); 

    } else if (data.type === 'EMOTE') { 
        // [BARU] Menangani Emote dari Lawan
        triggerEmoteDisplay(false, data.index);
    }
}



function requestRematch() {
    if(!rematchMe) {
        rematchMe = true;
        document.getElementById('btn-rematch').classList.add('btn-secondary');
        document.getElementById('btn-rematch').innerText = "REQUESTED";
        document.getElementById('rematch-msg').classList.remove('hidden');
        if(conn) conn.send({ type: 'REQUEST_REMATCH' });
        checkRematchStart();
    }
}

function checkRematchStart() {
    if(rematchMe && rematchOpp) {
        document.getElementById('game-over').style.display = 'none';
        resetGameVars();
        if(isHost) startMultiplayerGame();
    }
}
function resetGameVars() {
    rematchMe = false; rematchOpp = false;
    document.getElementById('btn-rematch').classList.remove('btn-secondary');
    document.getElementById('btn-rematch').innerText = "REMATCH";
    document.getElementById('rematch-msg').classList.add('hidden');
    projectiles = [];
    parryActive = false;
    
    // NEW
    isBlinded = false;
    blindTurnsLeft = 0;
}


function addCardToOpponentHand() {
    let c = new Card('fire', 1, false); 
    c.x = width/2; c.y = -50; 
    c.isFaceUp = false;
    opponentHand.push(c);
    rearrangeOpponentHand();
    playSound('deal');
}

function rearrangeOpponentHand() {
    let oppScale = 0.8;
    let oppW = cardW * oppScale;
    let oppH = cardH * oppScale;
    let oppSpread = Math.min(width / (opponentHand.length + 2), oppW * 0.8);
    let oppStart = width/2 - ((opponentHand.length - 1) * oppSpread) / 2;
    opponentHand.forEach((c, i) => {
        c.targetX = oppStart + i * oppSpread; 
        c.targetY = oppH * 0.6;
    });
}

function startMultiplayerGame() {
    gameState = 'PLAYING';
    cardsDealt = false; // Reset status kartu
    
    // Sembunyikan UI Lobby & Matchmaking
    const lobbyScreen = document.getElementById('lobby-screen');
    if(lobbyScreen) lobbyScreen.classList.add('hidden');
    
    const mmUI = document.getElementById('matchmaking-ui');
    if(mmUI) mmUI.classList.add('hidden');
    
    // PASTIKAN POPUP WIN/LOSE TERTUTUP
    const gameOverScreen = document.getElementById('game-over');
    if(gameOverScreen) gameOverScreen.style.display = 'none'; 
    
    // [FIX] Munculkan tombol emote untuk HOST
    const emoteContainer = document.getElementById('emote-container');
    if(emoteContainer) emoteContainer.classList.remove('hidden-ui');

    // 1. Siapkan Canvas
    const cvs = document.getElementById('gameCanvas');
    if(cvs) {
        cvs.style.display = 'block'; 
        resize(); 
    }
    
    // --- [UPDATE] LOGIKA PEMBAGIAN KARTU BARU (6 KARTU) ---
    function generateHand() {
        let h = [];
        
        // 1. Masukkan Kartu Spesial (PASTI DAPAT 1 JENIS MASING-MASING)
        h.push({suit: 'freeze', value: 0}); // 1 Freeze
        h.push({suit: 'purple', value: 0}); // 1 Blind
        h.push({suit: 'mirror', value: 0}); // 1 Mirror
        
        // 2. Masukkan 3 Kartu Basic Random
        for(let k=0; k<3; k++) {
            let s = BASIC_SUITS[Math.floor(Math.random() * BASIC_SUITS.length)];
            h.push({suit: s, value: Math.ceil(Math.random()*9)});
        }
        
        // 3. Acak posisi kartu di tangan agar musuh tidak bisa menebak letak kartu spesial
        for (let i = h.length - 1; i > 0; i--) { 
            const j = Math.floor(Math.random() * (i + 1)); 
            [h[i], h[j]] = [h[j], h[i]]; 
        }
        return h;
    }

    // 2. Generate Data
    let p1H = generateHand(); // Host Hand (6 Kartu)
    let p2H = generateHand(); // Client Hand (6 Kartu)
    
    let deckCount = 30; 
    let top = {suit: BASIC_SUITS[Math.floor(Math.random()*3)], value: Math.ceil(Math.random()*9)};
    
    // 3. Konversi Data Host menjadi Object Card
    let myStartCards = p1H.map(c => new Card(c.suit, c.value, true));
    let topCardObj = new Card(top.suit, top.value, true);
    
    // Tentukan Giliran
    turn = Math.random() > 0.5 ? 'me' : 'opponent';

    // 4. Kirim Data ke Client (Player 2)
    if(conn && conn.open) {
        conn.send({
            type: 'START_GAME', 
            deckCount: deckCount, 
            topDiscard: top,
            p1HandCount: p1H.length, // Dinamis (sekarang 6)
            p2Hand: p2H,             // Kirim 6 kartu milik client
            turn: turn === 'me' ? 'p1' : 'p2'
        });
    }

    // 5. Mulai Animasi di Layar Host (Passing jumlah kartu yang benar)
    playDealAnimation(myStartCards, p1H.length, topCardObj);
}




function playDealAnimation(myCards, oppCount, topCard) {
    isAnimating = true; myHand = []; opponentHand = []; discardPile = [];
    let dealSpeed = 100;

    oppCount = Number(oppCount);
    if (!isFinite(oppCount) || oppCount < 0) oppCount = Math.max(5, Math.floor(myCards.length));

    let totalCards = (Array.isArray(myCards) ? myCards.length : 0) + oppCount;
    let dealt = 0;
    let safetyCounter = 0; 

    function finishDeal() {
      cardsDealt = true;
        if (dealInterval) clearInterval(dealInterval);
        setTimeout(() => {
            try {
                topCard.x = 60; topCard.y = height/2 + 30; discardPile.push(topCard);
            } catch (e) { console.warn('finishDeal: topCard missing', e); }
            playSound('play');
            isAnimating = false;
            setTimeout(() => { showFloatingText(turn === 'me' ? "YOUR TURN" : "OPPONENT'S TURN", width/2, height/2 + 100, turn === 'me' ? "#0f0" : "#fff"); }, 500);
        }, 300);
    }

    let dealInterval = setInterval(() => {
        safetyCounter++;
        if (safetyCounter > 1000) { finishDeal(); return; }
        if (dealt >= totalCards) { finishDeal(); return; }

        let c = null;
        if (dealt % 2 === 0) {
            c = new Card('fire', 1, false);
            c.x = 60; c.y = height/2 + 30; c.isFaceUp = false;
            opponentHand.push(c);
        } else {
            let cardIndex = Math.floor(dealt / 2);
            if (Array.isArray(myCards) && myCards[cardIndex]) {
                c = myCards[cardIndex];
            } else {
                const s = BASIC_SUITS[Math.floor(Math.random() * BASIC_SUITS.length)];
                c = new Card(s, Math.ceil(Math.random() * 9), true);
            }
            c.x = 60; c.y = height/2 + 30; c.isFaceUp = false;
            myHand.push(c);
        }
        playSound('deal');
        dealt++;
    }, dealSpeed);

    setTimeout(() => { if (isAnimating) finishDeal(); }, 20000);
}

// --- [REPLACE] VALID MOVE CHECK ---
function isValidMove(card, topCard) {
    if (card.isFrozen) return false; // Kartu beku tidak bisa jalan secara logika move
    if (card.suit === 'mirror') return true; 
    if (card.suit === 'purple') return true; 
    if (card.suit === 'freeze') return true; // Freeze Universal
    if (topCard.suit === 'mirror') return true;
    if (topCard.suit === 'purple') return true; 
    if (topCard.suit === 'freeze') return true; // Bisa ditumpuk apa saja
    return card.suit === topCard.suit || card.value === topCard.value;
}




function playerInput(cardIndex) {
    // Cek basic (Game state, animasi, giliran)
    if (gameState !== 'PLAYING' || isAnimating) return false;
    
    // [FIX] Pastikan kartu yang diambil benar dari array
    let card = myHand[cardIndex];
    if (!card) return false; // Safety check

    let top = discardPile[discardPile.length - 1];
    card.isDragging = false; 

    // --- 1. LOGIKA PARRY (PRIORITAS TERTINGGI) ---
    if (canParry && slowMoActive) { 
        if (card.suit === 'mirror') {
            parryActive = true;
            setTimeout(() => { parryActive = false; }, 400);

            // Buang kartu Mirror ke tengah
            executeMove(cardIndex, card, top, false);
            
            // Eksekusi Parry
            projectiles.forEach(p => p.parry()); 
            showFloatingText("MIRROR PARRY!", width/2, height/2, COLORS.mirror);
            playSound('parry');
            
            // Matikan Slow Mo
            canParry = false;
            slowMoActive = false;
            
            conn.send({ type: 'PARRY_SUCCESS', card: { suit: card.suit, value: card.value } });
            return true;
        } else {
            showFloatingText("USE MIRROR!", card.x, card.y - 70, "red");
            card.shake = 20; playSound('error');
            return false;
        }
    }

    // Cek Giliran Normal
    if (turn !== 'me') return false;

    // --- 2. VALIDASI MOVE ---
    if (isValidMove(card, top)) {
        let isCrit = (card.suit !== 'mirror' && card.suit !== 'purple' && card.suit !== 'freeze' && COUNTER_MAP[card.suit] === top.suit);

        // A. Eksekusi Gerakan Fisik Kartu
        executeMove(cardIndex, card, top, isCrit);
        
        // B. [FIX] LOGIKA BLIND COUNTER & ENDING
        // Dijalankan SETELAH kartu dibuang, tapi SEBELUM ganti giliran
        if (isBlinded) {
            blindTurnsLeft--; // Kurangi jatah turn
            
            if (blindTurnsLeft <= 0) {
                // Jika ini turn terakhir blind
                endBlindMode(); 
                showFloatingText("SIGHT RESTORED!", width/2, height/2 - 50, "#FFF");
                
                // Kirim info ke lawan bahwa blind sudah habis
                if(conn && conn.open) conn.send({ type: 'BLIND_END' }); 
            } else {
                 showFloatingText(`Blind: ${blindTurnsLeft} turns left`, width/2, height/2 - 50, COLORS.purple);
            }
        }

        // C. Cek Menang (Double Check)
        if(myHand.length === 0) {
            // Kirim move terakhir sebelum menang
            conn.send({ type: 'OPPONENT_MOVE', card: {suit: card.suit, value: card.value}, isCrit: false }); 
            endGame("YOU WIN!", "Victory Achieved", true);
            return true;
        }

        // --- 3. LOGIKA EFEK KARTU & KIRIM DATA ---
        // [PENTING] Turn akan diganti ke 'opponent' di sini, 
        // tidak peduli apakah blind baru saja habis atau tidak.
        
        let moveData = {
            type: 'OPPONENT_MOVE',
            card: { suit: card.suit, value: card.value }, // Kirim suit asli
            isCrit: isCrit,
            effect: null
        };

        if (card.suit === 'mirror') {
             playSound('play');
             // Mirror = Wildcard, giliran tetap pindah ke lawan
             turn = 'opponent'; 
        
        } else if (card.suit === 'purple') {
             playSound('purple');
             showFloatingText("BLIND CAST!", width/2, height/2, COLORS.purple);
             moveData.effect = 'BLIND';
             turn = 'opponent';

        } else if (card.suit === 'freeze') {
             playSound('play');
             showFloatingText("FREEZE CAST!", width/2, height/2, COLORS.freeze);
             moveData.effect = 'FREEZE';
             turn = 'opponent'; 

        } else {
            // Kartu Biasa
            if(isCrit) spawnProjectiles(false, false); 
            turn = 'opponent';
        }

        // D. Kirim ke Lawan
        if(conn && conn.open) conn.send(moveData);

        return true;
        
    } else {
        // Jika Salah Jalan
        card.shake = 20;
        showFloatingText("Invalid Move", card.x, card.y - 50, "red");
        playSound('error');
        return false;
    }
}


function executeMove(index, card, top, isCrit) {
    checkFreezeStatus(); // Cek status beku sebelum jalan

    // 1. Hapus dari tangan
    myHand.splice(index, 1);
    
    // 2. Reset Status Visual Kartu (PENTING AGAR TIDAK BUG DI TENGAH)
    card.isSelected = false;
    card.isDragging = false; 
    card.isAnimatingPos = false;
    card.isHovered = false;
    
    // [FIX] Paksa kartu terbuka dan hapus status blind saat masuk discard pile
    card.isFaceUp = true; 
    card.isBlindPlaceholder = false; 
    // Kembalikan suit/value asli jika sebelumnya placeholder
    if (card.realSuit) card.suit = card.realSuit;
    if (card.realValue) card.value = card.realValue;

    // 3. Masukkan ke Discard Pile
    discardPile.push(card);
    
    // 4. Set Target Posisi ke Tengah
    card.targetX = width/2; 
    card.targetY = height/2;
    
    // 5. Audio & Win Check
    playSound('play');
    if(isCrit) {
        playSound('crit');
        showFloatingText("CRITICAL! (+2)", width/2, height/2 - 50, COLORS[card.suit]);
    }
    
    // 6. Cek Menang Segera setelah kartu berkurang
    checkWinCondition(); 
}


function spawnProjectiles(targetIsMe, slowMotion) {
    // Spawn 2 Kartu Kritikal
    // Kartu 1 (Langsung)
    projectiles.push(new ProjectileCard(targetIsMe, 0));
    
    // Kartu 2 (Sedikit delay 100ms agar terlihat seperti 2 kartu beriringan)
    projectiles.push(new ProjectileCard(targetIsMe, 150));
}


// --- [REPLACE] processOpponentMove ---
function processOpponentMove(cardData, isCrit, effect) {
    let card = new Card(cardData.suit, cardData.value, false);
    card.x = width / 2; card.y = -100;
    card.targetX = width / 2; card.targetY = height / 2;
    card.isFaceUp = true;

    if (opponentHand.length > 0) opponentHand.pop();
    rearrangeOpponentHand();
    discardPile.push(card);

       // --- EFFECT HANDLING ---
    if (cardData.suit === 'purple' || effect === 'BLIND') {
        playSound('purple');
        showFloatingText("YOU ARE BLINDED!", width / 2, height / 2, COLORS.purple);
        isBlinded = true;
        blindTurnsLeft = 3;
        
        // EFEK SPESIAL: JIKA KENA BLIND, EFEK BEKU HILANG
        let frozenCured = 0;
        myHand.forEach(c => {
            if(c.isFrozen) { c.isFrozen = false; c.freezeTimer = 0; frozenCured++; }
            // Acak fisika kartu karena buta
            c.vx = (Math.random() - 0.5) * 8;
            c.vy = (Math.random() - 0.5) * 8;
            c.rotSpeed = (Math.random() - 0.5) * 0.2;
        });

        // Jika ada es yang mencair, tampilkan efeknya
        if(frozenCured > 0) {
            showFloatingText("FROZEN CURED!", width/2, height/2 + 50, COLORS.freeze);
            playSound('freezeEnd'); 
        }

        // PERBAIKAN: turn = 'me' HARUS DI LUAR if(frozenCured > 0)
        // Agar giliran selalu kembali ke kita walaupun tidak sedang beku
        turn = 'me'; 
    }

    else if (cardData.suit === 'freeze' || effect === 'FREEZE') {
        // --- LOGIKA TERKENA FREEZE ---
        playSound('freezeStart');// Gunakan sfx ice jika ada
        showFloatingText("FROZEN!!", width / 2, height / 2, COLORS.freeze);
        
        // 1. Hitung jumlah kartu yang harus beku (Setengah, dibulatkan ke atas)
        // Jika kartu ganjil (misal 7), setengahnya 3.5 -> dibulatkan jadi 4
        let freezeCount = Math.ceil(myHand.length / 2);
        
        if (freezeCount > 0) {
            // 2. Acak indeks kartu
            let indices = Array.from({length: myHand.length}, (_, i) => i);
            // Fisher-Yates Shuffle sederhana untuk array indeks
            for (let i = indices.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [indices[i], indices[j]] = [indices[j], indices[i]];
            }
            
            // 3. Ambil N indeks pertama dan bekukan
            for(let k = 0; k < freezeCount; k++) {
                let targetIdx = indices[k];
                let targetCard = myHand[targetIdx];
                targetCard.isFrozen = true;
                targetCard.freezeTimer = 3; // Durasi 3 putaran
                targetCard.shake = 30; // Efek getar visual
            }
            showFloatingText(`${freezeCount} CARDS FROZEN`, width/2, height/2 + 50, COLORS.freeze);
        }
        turn = 'me';
    }
    else if (cardData.suit === 'mirror') {
        playSound('play');
        showFloatingText("WILDCARD!", width / 2, height / 2, COLORS.mirror);
        turn = 'me'; 
    } 
    else {
        if (isCrit) {
            playSound('crit');
            spawnProjectiles(true, false); 
        } else {
            playSound('play');
        }
        turn = 'me';
    }

    setTimeout(() => { checkWinCondition(); }, 500);
}

// GANTI SELURUH FUNCTION checkFreezeStatus DENGAN INI:
function checkFreezeStatus() {
    let frozenCount = 0;
    let hasMelted = false; // Penanda apakah ada kartu yang baru saja cair

    myHand.forEach(c => {
        if (c.isFrozen) {
            c.freezeTimer--;
            if (c.freezeTimer <= 0) {
                c.isFrozen = false; // Efek habis
                hasMelted = true;   // Tandai bahwa es mencair
            } else {
                frozenCount++;
            }
        }
    });

    // Jika ada yang mencair, mainkan suara 'freezeEnd'
    if (hasMelted) {
        playSound('freezeEnd');
        // Opsional: Tampilkan teks
        // showFloatingText("ICE MELTED", width/2, height/2 - 50, COLORS.freeze);
    }

    if (frozenCount > 0) {
        // Opsional: Tampilkan teks sisa beku
    }
}

// PISAHKAN FUNCTION INI KELUAR
function checkBlindStatus() {
    if (isBlinded) {
        blindTurnsLeft--;
        if (blindTurnsLeft <= 0) {
            isBlinded = false;
            showFloatingText("SIGHT RESTORED", width/2, height/2, "#FFF");
            
            // Kembalikan posisi kartu ke formasi rapi
            myHand.forEach(c => {
                c.angle = 0;
                c.vx = 0;
                c.vy = 0;
            });
            rearrangeHand(); // Pastikan fungsi ini ada atau gunakan arrangeHand() jika namanya beda
        } else {
            showFloatingText(`${blindTurnsLeft} TURNS LEFT`, width / 2, height / 2 + 60, COLORS.purple);
        }
    }
}

function rearrangeHand() {
    let pSpread = Math.min(width / (myHand.length + 1), cardW + 10);
    let pStart = width/2 - ((myHand.length - 1) * pSpread) / 2;
    myHand.forEach((c, i) => {
        c.targetX = pStart + i * pSpread;
        c.targetY = height - (cardH * 0.5);
    });
}


    // Screen Shake Logic
let shakeDuration = 0;
function startScreenShake() {
    shakeDuration = 20; // Frame durasi getar
}

// Update fungsi draw() sedikit untuk handle shake
function draw() {
    let shakeX = 0;
    let shakeY = 0;
    if (shakeDuration > 0) {
        shakeX = (Math.random() - 0.5) * 20;
        shakeY = (Math.random() - 0.5) * 20;
        shakeDuration--;
    }

    ctx.save();
    ctx.translate(shakeX, shakeY); // Terapkan getar ke seluruh canvas

    ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear dengan posisi relatif
}

function requestDraw() {
  checkFreezeStatus();

    if (gameState !== 'PLAYING' || turn !== 'me' || isAnimating || canParry) return;
    
    let newCard;
    if(isHost) newCard = drawCardFromDeckLogic();
    else {
        let r = Math.random();
        if (r < 0.08) newCard = new Card('mirror', 0, true);
        else {
            let s = BASIC_SUITS[Math.floor(Math.random()*3)]; let v = Math.floor(Math.random()*9)+1;
            newCard = new Card(s, v, true);
        }
    }

    if(newCard) {
        // Set posisi awal di deck
        newCard.x = 60; 
        newCard.y = height/2 + 30; 
        newCard.isFaceUp = false; 

        // JIKA BLIND: Pastikan kartu punya physics random
        if(isBlinded) {
          newCard.realSuit = newCard.suit;
        newCard.realValue = newCard.value;
        newCard.isBlindPlaceholder = true;
        
             newCard.initPhysics(); 
             newCard.isFaceUp = false; // tetap false sebelum animasi
             // Beri sedikit dorongan ke atas agar terlihat keluar dari deck
             newCard.vy = -5; 
             newCard.isFaceUp = false; // tetap false sebelum animasi
        newCard.startFlip();      // mulai animasi flip sekarang
    } else {
        // normal behaviour
        newCard.isFaceUp = false;
    }

    myHand.push(newCard);
    playSound('deal');

    // Kirim info ke lawan
    if (conn && conn.open) conn.send({ type: 'OPPONENT_DRAW' });

    // Jika tidak blind, rapikan tangan agar kartu mengambil slot
    if (!isBlinded) {
        rearrangeHand();
    }
    
    turn = 'opponent';
    showFloatingText("Turn Ended", width/2, height/2, "#aaa");
    }
} 


// --- [REPLACE] DECK GENERATION LOGIC ---
function drawCardFromDeckLogic() {
    let r = Math.random(); 
    if(r < 0.08) return new Card('mirror', 0, true);
    if(r < 0.15) return new Card('purple', 0, true); 
    if(r < 0.22) return new Card('freeze', 0, true); // 7% Chance for Freeze
    
    let s = BASIC_SUITS[Math.floor(Math.random()*3)]; 
    let v = Math.floor(Math.random()*9)+1;
    return new Card(s, v, true);
}



function spawnExplosion(x, y, color) {
    // Jika Graphics bukan HIGH, jangan spawn partikel (Hemat memori/CPU)
    if (graphicsQuality !== 'high') return; 

    for(let i=0; i<30; i++) {
        particles.push(new Particle(x, y, color, true));
    }
}

// --- PERBAIKAN FUNGSI ENDGAME (SATU UNTUK SEMUA) ---
function endGame(title, subtitle, isWin) {
    if (gameState === 'GAMEOVER') return; // Mencegah pemanggilan ganda
    gameState = 'GAMEOVER';

    console.log("Game Ended:", title);

    // 1. Mainkan Audio
    if (isWin) {
        playSound('win'); // Pastikan Anda punya case 'win' di playSound atau ganti 'crit'
    } else {
        playSound('error'); // Suara kalah
    }

    // 2. Tampilkan UI HTML (Overlay)
    const gameOverDiv = document.getElementById('game-over');
    const winnerText = document.getElementById('winner-text');
    const subText = document.getElementById('sub-winner-text');
    const rematchBtn = document.getElementById('btn-rematch');

    if (gameOverDiv && winnerText && subText) {
        winnerText.innerText = title;
        winnerText.style.color = isWin ? "#4CAF50" : "#F44336"; // Hijau jika menang, Merah jika kalah
        
        subText.innerText = subtitle;
        
        // Tampilkan Div
        gameOverDiv.style.display = 'block';
        
        // Reset tombol rematch
        if(rematchBtn) {
            rematchBtn.classList.remove('btn-secondary');
            rematchBtn.innerText = "REMATCH";
        }
    }

    // 3. Matikan Loop/Interaksi jika perlu
    // isAnimating = false;
}


function draw() {
    // Bersihkan layar sebelum menggambar frame baru
    ctx.clearRect(0, 0, canvas.width / (window.devicePixelRatio||1), canvas.height / (window.devicePixelRatio||1));
    
    // 1. Gambar Deck (Paling Bawah)
    let deckX = 60; let deckY = height / 2 + 30;
    if (IMAGES.back) {
        let stackHeight = 15;
        for (let i = 0; i < stackHeight; i++) {
            let off = i * 0.5; 
            ctx.save();
            ctx.translate(deckX - off, deckY - off);
            ctx.shadowColor = 'rgba(0,0,0,0.5)';
            ctx.shadowBlur = i === stackHeight - 1 ? 5 : 0; 
            ctx.drawImage(IMAGES.back, -cardW/2, -cardH/2, cardW, cardH);
            ctx.restore();
        }
    }

    // 2. Gambar Discard Pile (Kartu di Tengah)
    if (discardPile.length > 0) {
        let startIdx = Math.max(0, discardPile.length - 3);
        for(let i = startIdx; i < discardPile.length; i++) {
            let c = discardPile[i];
            c.targetX = width/2;
            c.targetY = height/2;
            if(!isAnimating && Math.abs(c.x - width/2) < 5) c.x = width/2;
            if(!isAnimating && Math.abs(c.y - height/2) < 5) c.y = height/2;
            c.draw(ctx, true, undefined, undefined, cardW, cardH);
        }
    }

    // 3. Gambar Kartu Lawan
    let oppScale = 0.8;
    let oppW = cardW * oppScale;
    let oppH = cardH * oppScale;
    let oppSpread = Math.min(width / (opponentHand.length + 2), oppW * 0.8);
    let oppStart = width/2 - ((opponentHand.length - 1) * oppSpread) / 2;
    opponentHand.forEach((c, i) => {
        c.targetX = oppStart + i * oppSpread; 
        c.targetY = oppH * 0.6; 
        c.draw(ctx, false, undefined, undefined, oppW, oppH);
    });

    // 4. Gambar Kartu Tangan Saya
    let pSpread = Math.min(width / (myHand.length + 1), cardW + 10);
    let pStart = width/2 - ((myHand.length - 1) * pSpread) / 2;
    myHand.forEach((c, i) => {
        if (!c.isDragging && !c.isAnimatingPos) {
            c.targetX = pStart + i * pSpread;
            let baseHeight = height - (cardH * 0.5); 
            if (c.isSelected) baseHeight = height - (cardH * 1.0);
            else if (c.isHovered) baseHeight = height - (cardH * 0.65);
            c.targetY = baseHeight;
        }
        if (i !== dragIdx) {
            c.draw(ctx, undefined, undefined, undefined, cardW, cardH);
        }
    });

    // 5. Gambar Kartu yang Sedang Di-drag
    if (dragIdx !== -1 && myHand[dragIdx]) {
        let c = myHand[dragIdx];
        c.draw(ctx, undefined, c.x, c.y, cardW, cardH);
    }

    // 6. Gambar PROYEKTIL/CRIT (DI ATAS SEMUA KARTU)
    projectiles.forEach(p => p.draw(ctx));

    // 7. Gambar Efek Visual & Teks (Paling Depan)
    particles.forEach(p => p.draw(ctx));
    floatingTexts.forEach(t => t.draw(ctx));

    if(gameState === 'PLAYING' && !isAnimating) {
        ctx.font = "bold 16px Orbitron"; ctx.fillStyle = turn === 'me' ? '#00FF00' : '#888'; ctx.textAlign = 'center';
        let txt = turn === 'me' ? "YOUR TURN" : "OPPONENT'S TURN";
        if(canParry) txt = "!!! PARRY CHANCE !!!";
        ctx.fillText(txt, width/2, height/2 + cardH/2 + 50);
    }

    // 8. [BARU] DRAW EMOTES (OVERLAY PALING ATAS)
    
    // Emote Kita (Muncul di dekat tangan kita)
    if (activeEmote.me.timer > 0) {
        let scale = 1;
        if (activeEmote.me.timer > EMOTE_DURATION - 10) scale = 1.2; // Animasi pop up
        
        // Background bubble (opsional)
        ctx.fillStyle = "rgba(255, 255, 255, 0.15)";
        ctx.beginPath(); 
        ctx.arc(width/2 - 120, height - 200, 40 * scale, 0, Math.PI*2);
        ctx.fill();

        // Gambar Emote Sprite
        drawEmoteSprite(ctx, activeEmote.me.id, width/2 - 120, height - 200, 60 * scale);
        
        activeEmote.me.timer--;
    }

    // Emote Lawan (Muncul di area lawan)
    if (activeEmote.opp.timer > 0) {
        let scale = 1;
        if (activeEmote.opp.timer > EMOTE_DURATION - 10) scale = 1.2;

        // Background bubble
        ctx.fillStyle = "rgba(255, 255, 255, 0.15)";
        ctx.beginPath(); 
        ctx.arc(width/2 + 120, 180, 40 * scale, 0, Math.PI*2);
        ctx.fill();

        // Gambar Emote Sprite
        drawEmoteSprite(ctx, activeEmote.opp.id, width/2 + 120, 180, 60 * scale);
        
        activeEmote.opp.timer--;
    }
}



function update() {
    // 1. Update Particles
    for (let i = particles.length - 1; i >= 0; i--) { 
        particles[i].update(); 
        if (particles[i].life <= 0) particles.splice(i, 1); 
    }

    // 2. Update Floating Text
    for (let i = floatingTexts.length - 1; i >= 0; i--) { 
        floatingTexts[i].update(); 
        if (floatingTexts[i].life <= 0) floatingTexts.splice(i, 1); 
    }

    // 3. Update Projectiles (NEW LOGIC)
    for (let i = projectiles.length - 1; i >= 0; i--) {
        let p = projectiles[i];
        p.update(); // Update physics & phase
        if (p.isDead) projectiles.splice(i, 1);
    }

    // 4. Global Slow Motion Controller
    // Kita Lerp timeScale agar transisi smooth (1.0 <-> 0.2)
    let targetTimeScale = slowMoActive ? 0.2 : 1.0;
    timeScale += (targetTimeScale - timeScale) * 0.1; // Smooth transition value

    // 5. Update Physics Blind Mode (Zero Gravity)
    if (isBlinded && gameState === 'PLAYING') {
        let handAreaY = height / 2 + 50; 
        myHand.forEach(c => {
            c.updateFloating(handAreaY);
        });
    }
}



function loop() { update(); draw(); requestAnimationFrame(loop); }

function resize() { 
    // Default DPI
    let dpr = window.devicePixelRatio || 1;
    
    // Jika Graphics LOW, turunkan resolusi (0.6x dari native)
    if (graphicsQuality === 'low') {
        dpr = dpr * 0.6; 
    }

    // Reset transform sebelum scaling
    ctx.setTransform(1, 0, 0, 1, 0, 0);

    // Atur ukuran Canvas
    canvas.width = window.innerWidth * dpr;
    canvas.height = window.innerHeight * dpr;
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    
    // Scale Context
    ctx.scale(dpr, dpr);
    
    width = window.innerWidth; 
    height = window.innerHeight;

    let refWidth = Math.min(width, 500);
    cardScale = refWidth / 500; 
    cardW = Math.max(60, 100 * cardScale); 
    cardH = cardW / CARD_RATIO;
}


function getCardAt(x, y) {
    for (let i = myHand.length - 1; i >= 0; i--) {
        let c = myHand[i];
        if (x > c.x - cardW/2 && x < c.x + cardW/2 && 
            y > c.y - cardH/2 && y < c.y + cardH/2) {
            return i;
        }
    }
    return -1;
}

function onPointerDown(e) {
      // Logika Restart jika Game Over
    if (gameState === 'GAMEOVER') {
        location.reload(); // Reload halaman untuk main ulang
        return;
    }
      if (audioCtx.state === 'suspended') audioCtx.resume();
    startBGM(); // Mencoba menyalakan BGM saat interaksi pertama

    if (gameState !== 'PLAYING' || isAnimating || (turn !== 'me' && !canParry)) return;
    if (gameState !== 'PLAYING' || isAnimating || (turn !== 'me' && !canParry)) return;
    
    if (audioCtx.state === 'suspended') audioCtx.resume();

    let rect = canvas.getBoundingClientRect();
    let x = (e.clientX || e.touches[0].clientX) - rect.left;
    let y = (e.clientY || e.touches[0].clientY) - rect.top;
    
    let deckX = 60; let deckY = height/2 + 30;
    if (x > deckX - cardW/2 - 20 && x < deckX + cardW/2 + 20 &&
        y > deckY - cardH/2 - 20 && y < deckY + cardH/2 + 20) {
        requestDraw();
        return;
    }

    let idx = getCardAt(x, y);

    if (idx !== -1) {
          if (myHand[idx].isFrozen) {
        showFloatingText("FROZEN!", myHand[idx].x, myHand[idx].y - 60, COLORS.freeze);
        myHand[idx].shake = 20;
        playSound('error');
        return; // Hentikan fungsi, tidak bisa diklik/drag
    }
        if (selectedIdx === idx) {
             let success = playerInput(idx);
             if (success) {
                 selectedIdx = -1;
                 dragIdx = -1;
                 return;
             }
        }

        if (selectedIdx !== -1 && selectedIdx !== idx && myHand[selectedIdx]) {
            myHand[selectedIdx].isSelected = false;
        }

        selectedIdx = idx;
        dragIdx = idx; 
        
        let c = myHand[idx];
        c.isSelected = true;
        c.isDragging = true;
                c.isAnimatingPos = false;
        c.angle = 0; // Luruskan kartu agar pemain sadar sudah tertangkap
        c.vx = 0;    // Hentikan momentum
        c.vy = 0;
        dragOffsetX = x - c.x;
        dragOffsetY = y - c.y;
        
        playSound('deal'); 
 
    } else {
        if(selectedIdx !== -1 && myHand[selectedIdx]) {
            myHand[selectedIdx].isSelected = false;
            selectedIdx = -1;
        }
    }
}

function onPointerMove(e) {
    let rect = canvas.getBoundingClientRect();
    let x = (e.clientX || (e.touches ? e.touches[0].clientX : 0)) - rect.left;
    let y = (e.clientY || (e.touches ? e.touches[0].clientY : 0)) - rect.top;

    if (dragIdx !== -1) {
        e.preventDefault(); 
        myHand[dragIdx].x = x - dragOffsetX;
        myHand[dragIdx].y = y - dragOffsetY;
    } else {
        let hovered = false;
        for (let i = myHand.length - 1; i >= 0; i--) {
             c = myHand[i];
            if (!hovered && x > c.x - cardW/2 && x < c.x + cardW/2 && 
                y > c.y - cardH/2 && y < c.y + cardH/2) {
                c.isHovered = true; hovered = true;
            } else c.isHovered = false;
        }
    }
}

function onPointerUp(e) {
    if (dragIdx !== -1) {
         c = myHand[dragIdx];
        c.isDragging = false;
        
        let dist = Math.hypot(c.x - width/2, c.y - height/2);
        
        if (dist < 150) {
            let success = playerInput(dragIdx);
            if (!success) {
                c.isAnimatingPos = false; 
            }
        }
        dragIdx = -1;
    }
}

window.addEventListener('resize', resize);
canvas.addEventListener('mousedown', onPointerDown);
canvas.addEventListener('mousemove', onPointerMove);
window.addEventListener('mouseup', onPointerUp);

canvas.addEventListener('touchstart', onPointerDown, {passive: false});
canvas.addEventListener('touchmove', onPointerMove, {passive: false});
window.addEventListener('touchend', onPointerUp);

function roundRect(ctx, x, y, w, h, r) { ctx.beginPath(); ctx.roundRect(x, y, w, h, r); ctx.closePath(); }
function showFloatingText(txt, x, y, c) { 
    floatingTexts.push({ text: txt, x: x, y: y, color: c, life: 1, update: function(){this.y-=1.5; this.life-=0.02;}, draw: function(ctx){
        ctx.globalAlpha=Math.max(0,this.life); ctx.fillStyle=this.color; ctx.strokeStyle='#000'; ctx.lineWidth=3;
        ctx.font="bold 24px Orbitron"; ctx.strokeText(this.text,this.x,this.y); ctx.fillText(this.text,this.x,this.y); ctx.globalAlpha=1;
    }});
}
// --- SETTINGS LOGIC ---
function openSettings() {
    document.getElementById('settings-modal').classList.add('active');
}

function closeSettings() {
    document.getElementById('settings-modal').classList.remove('active');
}

function setQuality(level) {
    graphicsQuality = level;
    
    // Update UI Buttons
    document.getElementById('q-low').classList.remove('active');
    document.getElementById('q-med').classList.remove('active');
    document.getElementById('q-high').classList.remove('active');
    
    if(level === 'low') document.getElementById('q-low').classList.add('active');
    if(level === 'medium') document.getElementById('q-med').classList.add('active');
    if(level === 'high') document.getElementById('q-high').classList.add('active');

    // Trigger Resize untuk update resolusi (jika Low)
    resize();
    
    // Feedback Sound (opsional jika sound system aktif)
    playSound('play'); 
}

resize();
loadAssets();
loop();
</script>
</body>
</html>
