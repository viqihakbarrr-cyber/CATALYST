<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ELUNO MIRROR - FIXED</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Orbitron:wght@400;700;900&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Orbitron', sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
            background-image: url('https://github.com/viqihakbarrr-cyber/kkk/blob/main/BG.png?raw=true');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100vh;
            background: transparent; 
        }

        #ui-layer, #lobby-screen, #loading-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            pointer-events: none;
        }

        #lobby-screen, #game-over, #fs-toggle {
            pointer-events: auto;
        }

        #lobby-screen {
            background: rgba(0, 0, 0, 0.85);
            z-index: 200;
            backdrop-filter: blur(8px);
        }
        /* --- LOADING SCREEN BARU --- */
        #loading-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column;
            justify-content: flex-end; /* Posisi di bawah */
            align-items: center;
            z-index: 300;
            
            /* Background Baru */
            background-image: url('https://github.com/viqihakbarrr-cyber/kkk/blob/main/IceLoadS.jpg?raw=true');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        /* Container untuk bar dan text di bawah */
        .loading-container {
            width: 80%;
            max-width: 600px;
            margin-bottom: 50px; /* Jarak dari bawah layar */
            text-align: center;
        }

        .loading-detail-text {
            color: #9933FF;
            font-size: 14px;
            font-weight: bold;
            letter-spacing: 1px;
            margin-bottom: 10px;
            text-shadow: 0 0 5px rgba(0,0,0,0.8);
            font-family: 'Orbitron', sans-serif;
            text-transform: uppercase;
        }

        .progress-bar- {
            width: 100%;
            height: 8px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #333;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
        }

        .progress-bar-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #7700FF, #CC44FF);
            box-shadow: 0 0 10px #9933FF;
            transition: width 0.2s ease-out;
        }



        .modal-box {
            background: rgba(255, 255, 255, 0.95);
            padding: 40px; border-radius: 15px; text-align: center;
            box-shadow: 0 0 40px rgba(153, 51, 255, 0.3);
            border: 4px solid #333; max-width: 65%; width: 400px;
        }

        h1 { margin: 0 0 20px 0; color: #000; font-size: 28px; letter-spacing: 2px; }
        h2 { margin: 0 0 15px 0; color: #333; font-size: 18px; }
        
        .input-group { margin-bottom: 20px; }
        input[type="number"] {
            padding: 10px; font-family: 'Orbitron'; font-size: 24px; text-align: center;
            border: 2px solid #333; border-radius: 10px; width: 150px; outline: none;
        }
        input[type="number"]:focus { border-color: #9933FF; }

        .room-code-display {
            font-size: 36px; font-weight: bold; color: #9933FF; margin: 20px 0; letter-spacing: 5px;
        }

        button.main-btn {
            padding: 15px 30px; background: #000; border: none; color: white;
            font-family: 'Orbitron', sans-serif; font-size: 16px; font-weight: bold;
            cursor: pointer; border-radius: 50px; transition: all 0.2s;
            margin: 10px; min-width: 150px;
        }
        button.main-btn:hover { transform: scale(1.05); box-shadow: 0 0 15px rgba(153, 51, 255, 0.5); }
        button.main-btn.active { background: linear-gradient(45deg, #7700FF, #CC44FF); }
        .btn-secondary { background: #555 !important; }

        #game-over {
            display: none; background: rgba(255, 255, 255, 0.95);
            padding: 40px; border-radius: 20px; text-align: center; border: 3px solid #333;
            pointer-events: auto; box-shadow: 0 0 50px rgba(255, 255, 255, 0.5);
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        }

        #fs-toggle {
            position: absolute;
            top: 20px; right: 20px;
            width: 44px; height: 44px;
            background: rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            cursor: pointer;
            z-index: 1000;
            display: flex; justify-content: center; align-items: center;
            transition: all 0.3s ease;
            backdrop-filter: blur(4px);
        }
        #fs-toggle:hover { background: rgba(153, 51, 255, 0.8); border-color: #fff; transform: scale(1.1); }
        
        #fs-icon svg {
            width: 24px; height: 24px; fill: white;
            filter: drop-shadow(0 0 2px rgba(0,0,0,0.5));
        }

        .hidden { display: none !important; }
        
        .rematch-status {
            font-size: 14px; color: #666; margin-top: 10px; font-weight: bold;
        }

    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="fs-toggle" onclick="toggleFullscreen()">
        <div id="fs-icon">
            <svg viewBox="0 0 24 24">
                <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"/>
            </svg>
        </div>
    </div>

        <div id="loading-layer">
        <div class="loading-container">
            <div class="loading-detail-text" id="loading-text-detail">INITIALIZING SYSTEM... 0%</div>
            
            <div class="progress-bar-bg">
                <div class="progress-bar-fill" id="loading-bar-fill"></div>
            </div>
        </div>
    </div>


    <div id="lobby-screen" class="hidden">
        <div class="modal-box" id="lobby-main">
            <h1>ELUNO MIRROR</h1>
            <p style="color:#666; margin-bottom:20px;">MULTIPLAYER EDITION</p>
            <button class="main-btn active" onclick="startMatchmaking()">FIND MATCH</button>
            <br>
            <p style="font-size: 12px; color: #999; margin-top: 15px;">Broker: <span id="broker-status">Checking...</span></p>
        </div>
        <div class="modal-box hidden" id="lobby-searching">
            <h2>SEARCHING...</h2>
            <div class="spinner"></div>
            <p id="search-status">Connecting to matchmaking server...</p>
            <p id="queue-position" style="font-size: 14px; color: #666;"></p>
            <br>
            <button class="main-btn btn-secondary" onclick="cancelMatchmaking()">CANCEL</button>
        </div>
        <div class="modal-box hidden" id="lobby-connecting">
            <h2>MATCH FOUND!</h2>
            <div class="spinner"></div>
            <p id="connecting-status">Establishing P2P connection...</p>
            <br>
            <button class="main-btn btn-secondary" onclick="cancelMatchmaking()">CANCEL</button>
        </div>
    </div>

    <div id="ui-layer">
        <div id="game-over">
            <h1 id="winner-text">YOU WIN!</h1>
            <p id="sub-winner-text" style="color:#666; margin-bottom:20px;">Opponent Disconnected</p>
            <button id="btn-rematch" class="main-btn active" onclick="requestRematch()">REMATCH</button>
            <br>
            <div id="rematch-msg" class="rematch-status hidden">Waiting for opponent...</div>
            <button class="main-btn btn-secondary" onclick="location.reload()">MAIN MENU</button>
        </div>
    </div>

<script>
// --- AUDIO MANAGEMENT ---
const SFX_URL = 'https://cdn.jsdelivr.net/gh/viqihakbarrr-cyber/kkk@main/sfxnbs.ogg';
const SFX_SPRITES = {
    deal:   { start: 0,  dur: 1 },
    flip:   { start: 2,  dur: 1 },
    play:   { start: 3,  dur: 1 },
    error:  { start: 6,  dur: 1 },
    crit:   { start: 9,  dur: 4 },
    moon:   { start: 19, dur: 5 },
    parry:  { start: 14, dur: 3 }
};

const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let sfxBuffer = null;
let bgmNode = null; // Variabel baru untuk BGM
let bgmGainNode = null;

async function loadAudioBuffer() {
    try {
        const response = await fetch(SFX_URL);
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const arrayBuffer = await response.arrayBuffer();
        sfxBuffer = await audioCtx.decodeAudioData(arrayBuffer);
        return true;
    } catch (e) {
        console.warn("Audio failed to load:", e);
        // Gunakan ID yang baru jika error
        const detailText = document.getElementById('loading-text-detail');
        if(detailText) detailText.innerText = "AUDIO FAILED (SKIPPING...)";
        return false; 
    }
}


function playSound(type) {
    if (!sfxBuffer) return;
    if (audioCtx.state === 'suspended') audioCtx.resume();
    const sprite = SFX_SPRITES[type];
    if (sprite) {
        const source = audioCtx.createBufferSource();
        source.buffer = sfxBuffer;
        if(type === 'parry') source.playbackRate.value = 1.5; 
        source.connect(audioCtx.destination);
        source.start(0, sprite.start, sprite.dur);
    }
}

// === TAMBAHKAN FUNGSI INI UNTUK BGM ===
function startBGM() {
    // Cek jika audio context belum aktif atau buffer belum siap atau BGM sudah jalan
    if (!sfxBuffer || bgmNode) return;
    if (audioCtx.state === 'suspended') audioCtx.resume();

    try {
        bgmNode = audioCtx.createBufferSource();
        bgmNode.buffer = sfxBuffer;
        
        // Loop settings: 00:40 sampai 02:53
        // 02:53 = (2 * 60) + 53 = 173 detik
        bgmNode.loop = true;
        bgmNode.loopStart = 40; 
        bgmNode.loopEnd = 173; 

        bgmGainNode = audioCtx.createGain();
        bgmGainNode.gain.value = 1.0; // Volume 100%

        bgmNode.connect(bgmGainNode);
        bgmGainNode.connect(audioCtx.destination);

        // Mulai play dari detik ke-40
        bgmNode.start(0, 40);
        console.log("BGM Started");
    } catch (e) {
        console.error("BGM Error:", e);
    }
}

// --- ASSET MANAGEMENT ---
const ASSETS_URL = {
    fire: 'https://github.com/viqihakbarrr-cyber/kkk/blob/main/BCfire.png?raw=true',
    water: 'https://github.com/viqihakbarrr-cyber/kkk/blob/main/BCwater.png?raw=true',
    leaf: 'https://github.com/viqihakbarrr-cyber/kkk/blob/main/BCleaf.png?raw=true',
    moon: 'https://github.com/viqihakbarrr-cyber/kkk/blob/main/SCpurple.png?raw=true',
    mirror: 'https://github.com/viqihakbarrr-cyber/kkk/blob/main/SCmiror.png?raw=true',
    back: 'https://github.com/viqihakbarrr-cyber/kkk/blob/main/Back.png?raw=true'
};

const IMAGES = {};
let assetsLoaded = false;

function loadAssets() {
    let loadedCount = 0;
    const imgKeys = Object.keys(ASSETS_URL);
    const total = imgKeys.length + 1; // +1 untuk Audio
    
    // Ambil elemen DOM baru
    const barFill = document.getElementById('loading-bar-fill');
    const textDetail = document.getElementById('loading-text-detail');

    function updateProgress(itemName) {
        loadedCount++;
        const percent = Math.round((loadedCount / total) * 100);
        
        // Update tampilan Loading Screen
        if(barFill) barFill.style.width = `${percent}%`;
        if(textDetail) textDetail.innerText = `LOADING ${itemName || 'DATA'}... (${percent}%)`;

        if(loadedCount >= total) {
            assetsLoaded = true;
            setTimeout(() => {
                document.getElementById('loading-layer').classList.add('hidden');
                document.getElementById('lobby-screen').classList.remove('hidden');
                checkBrokerConnection();
            }, 800);
        }
    }

    // Load Images
    imgKeys.forEach(key => {
        const img = new Image();
        img.src = ASSETS_URL[key];
        img.onload = () => updateProgress(key.toUpperCase());
        img.onerror = () => { console.warn("Failed asset:", key); updateProgress(key.toUpperCase()); };
        IMAGES[key] = img;
    });

    // Load Audio
    loadAudioBuffer().then(() => updateProgress("AUDIO SYSTEM"));
}


// --- KONFIGURASI NETWORK ---
let peer = null;
let conn = null;
let myPeerID = null;
let isHost = false;
let rematchMe = false;
let rematchOpp = false;

// Matchmaking Configuration
const BROKER_URL = "https://beagle-causal-gorilla.ngrok-free.app"; // Change this to your deployed broker URL
let socket = null;
let isSearching = false;
let matchmakingTimeout = null;

// --- KONFIGURASI CANVAS & GAME ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let width, height;
let particles = [];
let floatingTexts = [];
let projectiles = [];

const CARD_RATIO = 2.5 / 4.0;
let cardScale = 1;
let cardW = 100;
let cardH = 160;

const SUITS = ['fire', 'water', 'leaf', 'moon', 'mirror'];
const BASIC_SUITS = ['fire', 'water', 'leaf'];
const COLORS = { fire: '#FF2222', water: '#0088FF', leaf: '#00CC44', moon: '#9933FF', mirror: '#00FFFF' };
const COUNTER_MAP = { fire: 'leaf', leaf: 'water', water: 'fire' };

let deck = [];
let discardPile = [];
let myHand = [];
let opponentHand = []; 
let turn = ''; 
let gameState = 'MENU'; 
let isAnimating = false; 

let selectedIdx = -1;
let dragIdx = -1;
let dragOffsetX = 0;
let dragOffsetY = 0;

let blindMode = false;
let blindIntensity = 0; 
let mustPlayBasic = false; 
let canParry = false; 

// Fullscreen Logic
document.addEventListener('fullscreenchange', () => {
    const btn = document.getElementById('fs-toggle');
    btn.style.display = document.fullscreenElement ? 'none' : 'flex'; 
});
function toggleFullscreen() {
    if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(err => console.log(err));
    }
}

function easeInOutCubic(x) {
    return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2;
}

class Card {
    constructor(suit, value, isMine = true) {
        this.suit = suit; this.value = value;
        this.isMine = isMine;
        this.id = Math.random().toString(36).substr(2, 9);
        this.x = 60; this.y = height/2 + 30; 
        
        this.startX = this.x; this.startY = this.y;
        this.targetX = width / 2; this.targetY = height / 2;
        this.animStartTime = 0;
        this.animDuration = 0;
        this.isAnimatingPos = false;

        this.shake = 0;
        this.isHovered = false;
        this.isSelected = false; 
        this.isDragging = false; 

        this.isFaceUp = isMine; 
        this.scaleX = 1;      
        this.flipping = false;
    }

    moveTo(tx, ty, duration) {
        this.startX = this.x; this.startY = this.y;
        this.targetX = tx; this.targetY = ty;
        this.animDuration = duration;
        this.animStartTime = performance.now();
        this.isAnimatingPos = true;
    }

    draw(ctx, forceFaceUp, x, y, w, h) {
        let drawW = w || cardW;
        let drawH = h || cardH;

        if (this.isDragging) {
            this.x = x; this.y = y;
            this.isAnimatingPos = false; 
        } else if (this.isAnimatingPos) {
            let elapsed = performance.now() - this.animStartTime;
            let progress = Math.min(elapsed / this.animDuration, 1);
            let ease = easeInOutCubic(progress);

            this.x = this.startX + (this.targetX - this.startX) * ease;
            this.y = this.startY + (this.targetY - this.startY) * ease;
            if (progress >= 1) this.isAnimatingPos = false;
        } else {
            this.x += (this.targetX - this.x) * 0.15;
            this.y += (this.targetY - this.y) * 0.15;
        }

        if (this.isMine && !this.isFaceUp && !this.flipping && Math.abs(this.x - this.targetX) < 10) {
            this.startFlip();
        }

        if (this.flipping) {
            if (!this.isFaceUp) {
                this.scaleX -= 0.15;
                if (this.scaleX <= 0) { this.scaleX = 0; this.isFaceUp = true; playSound('flip'); }
            } else {
                this.scaleX += 0.15;
                if (this.scaleX >= 1) { this.scaleX = 1; this.flipping = false; }
            }
        }

        let offsetX = 0; if (this.shake > 0) { offsetX = Math.sin(Date.now() * 0.5) * 5; this.shake -= 1; }

        ctx.save();
        ctx.translate(this.x + offsetX, this.y);

        let s = 1.0;
        if(this.isSelected) s = 1.1;
        if(this.isDragging) s = 1.15;
        
        ctx.scale(s * this.scaleX, s);

        let showFace = (forceFaceUp !== undefined) ? forceFaceUp : this.isFaceUp;

        if (showFace) {
            if(this.suit === 'moon') {
                ctx.shadowColor = COLORS.moon; ctx.shadowBlur = 20;
            } else if (this.suit === 'mirror') {
                ctx.shadowColor = COLORS.mirror; ctx.shadowBlur = 20;
            } else {
                ctx.shadowColor = 'rgba(0,0,0,0.5)'; ctx.shadowBlur = (this.isSelected || this.isDragging) ? 25 : 5;
            }
            ctx.shadowOffsetY = (this.isSelected || this.isDragging) ? 15 : 5;

            if (IMAGES[this.suit]) {
                ctx.drawImage(IMAGES[this.suit], -drawW/2, -drawH/2, drawW, drawH);
            } else {
                ctx.fillStyle = '#fff'; ctx.fillRect(-drawW/2, -drawH/2, drawW, drawH);
            }
            ctx.shadowBlur = 0; ctx.shadowOffsetY = 0;

            if (this.suit !== 'moon' && this.suit !== 'mirror') {
                ctx.fillStyle = "#FFFFFF"; ctx.strokeStyle = "#000000"; ctx.lineWidth = 2; 
                let fontSize = drawW * 0.18; 
                ctx.font = `700 ${fontSize}px 'Cinzel', serif`;
                let padX = drawW * 0.12; let padY = drawH * 0.1;
                ctx.textAlign = 'left'; ctx.textBaseline = 'top';
                ctx.strokeText(this.value, -drawW/2 + padX, -drawH/2 + padY);
                ctx.fillText(this.value, -drawW/2 + padX, -drawH/2 + padY);
                ctx.textAlign = 'right'; ctx.textBaseline = 'bottom';
                ctx.strokeText(this.value, drawW/2 - padX, drawH/2 - padY);
                ctx.fillText(this.value, drawW/2 - padX, drawH/2 - padY);
            }
        } else {
            ctx.shadowColor = 'rgba(0,0,0,0.5)'; ctx.shadowBlur = 5;
            if(IMAGES.back) {
                ctx.drawImage(IMAGES.back, -drawW/2, -drawH/2, drawW, drawH);
            } else {
                ctx.fillStyle = '#333'; ctx.fillRect(-drawW/2, -drawH/2, drawW, drawH);
            }
        }
        ctx.restore();
    }

    startFlip() { this.flipping = true; }
}

class ProjectileCard {
    constructor(targetIsMe, slowMotion) {
        this.x = width / 2;
        this.y = height / 2;
        this.targetIsMe = targetIsMe;
        this.creationTime = Date.now();
        this.isSlow = slowMotion;
        this.speed = slowMotion ? 1.0 : 15; 
        this.isDead = false;
        this.angle = 0;
    }

    update() {
        if (this.isSlow) {
            if (Date.now() - this.creationTime > 2000) {
                this.isSlow = false;
                this.speed = 15; 
                canParry = false; 
                showFloatingText("TOO LATE!", width/2, height/2, "#666");
            }
        }

        if (this.targetIsMe) {
            this.y += this.speed;
            if (this.y > height - 100) this.isDead = true; 
        } else {
            this.y -= this.speed; 
            if (this.y < 100) this.isDead = true;
        }
        this.angle += 0.1;
    }

    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        if(IMAGES.back) {
            ctx.drawImage(IMAGES.back, -cardW/2, -cardH/2, cardW, cardH);
        } else {
            ctx.fillStyle = '#333'; ctx.fillRect(-cardW/2, -cardH/2, cardW, cardH);
        }
        
        if(this.isSlow) {
            ctx.strokeStyle = '#00FFFF'; ctx.lineWidth = 4;
            ctx.strokeRect(-cardW/2, -cardH/2, cardW, cardH);
        }
        ctx.restore();
    }
}

class Particle {
    constructor(x, y, color, isExplosion) {
        this.x = x; this.y = y; this.color = color;
        this.size = Math.random() * 5 + 2;
        let speed = isExplosion ? 15 : 10;
        this.vx = (Math.random() - 0.5) * speed;
        this.vy = (Math.random() - 0.5) * speed;
        this.life = 1;
    }
    update() {
        this.x += this.vx; this.y += this.vy;
        this.life -= 0.02; this.size *= 0.95;
    }
    draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.life);
        ctx.fillStyle = this.color;
        ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill(); ctx.globalAlpha = 1;
    }
}

// --- MATCHMAKING & NETWORKING FUNCTIONS ---

// UI Helper Functions
function showLoading(msg) {
    const layer = document.getElementById('loading-layer');
    layer.classList.remove('hidden'); 
    layer.style.background = 'rgba(0,0,0,0.8)';
    document.getElementById('loading-msg').innerText = msg;
}

function hideLoading() { 
    document.getElementById('loading-layer').classList.add('hidden'); 
}

function showSearchingUI() {
    document.getElementById('lobby-main').classList.add('hidden');
    document.getElementById('lobby-searching').classList.remove('hidden');
    document.getElementById('search-status').innerText = 'Connecting to matchmaking server...';
    document.getElementById('queue-position').innerText = '';
}

function showConnectingUI() {
    document.getElementById('lobby-searching').classList.add('hidden');
    document.getElementById('lobby-connecting').classList.remove('hidden');
    document.getElementById('connecting-status').innerText = 'Establishing P2P connection...';
}

function resetLobby() {
    // Clean up all connections
    if (socket) {
        socket.disconnect();
        socket = null;
    }
    if (peer) {
        peer.destroy();
        peer = null;
    }
    conn = null;
    isSearching = false;
    isHost = false;
    
    // Reset UI
    document.getElementById('lobby-main').classList.remove('hidden');
    document.getElementById('lobby-searching').classList.add('hidden');
    document.getElementById('lobby-connecting').classList.add('hidden');
    document.getElementById('lobby-screen').classList.remove('hidden');
    
    hideLoading();
    
    // Clear any timeouts
    if (matchmakingTimeout) {
        clearTimeout(matchmakingTimeout);
        matchmakingTimeout = null;
    }
}

// --- BROKER CONNECTION & MATCHMAKING ---

function checkBrokerConnection() {
    const statusEl = document.getElementById('broker-status');
    if (!statusEl) return;
    
    fetch(BROKER_URL + '/health')
        .then(response => response.json())
        .then(data => {
            statusEl.innerText = 'Online';
            statusEl.style.color = '#00FF00';
        })
        .catch(error => {
            statusEl.innerText = 'Offline';
            statusEl.style.color = '#FF0000';
            console.error('Broker server unavailable:', error);
        });
}

function startMatchmaking() {
  startBGM();
    if (isSearching) return;
    
    // Check broker first
    showSearchingUI();
    isSearching = true;
    
    // Load Socket.io dynamically
    if (typeof io === 'undefined') {
        const script = document.createElement('script');
        script.src = 'https://cdn.socket.io/4.7.2/socket.io.min.js';
        script.onload = () => initializeSocket();
        script.onerror = () => {
            document.getElementById('search-status').innerText = 'Failed to load Socket.io. Please check your connection.';
            isSearching = false;
            setTimeout(() => resetLobby(), 3000);
        };
        document.head.appendChild(script);
    } else {
        initializeSocket();
    }
}

function initializeSocket() {
    try {
        socket = io(BROKER_URL, {
            transports: ['websocket', 'polling'],
            reconnection: false,
            timeout: 10000
        });

        socket.on('connect', () => {
            console.log('Connected to matchmaking server');
            document.getElementById('search-status').innerText = 'Connected. Generating Peer ID...';
            
            // Create PeerJS instance
            createPeerForMatchmaking();
        });

        socket.on('connect_error', (error) => {
            console.error('Socket connection error:', error);
            document.getElementById('search-status').innerText = 'Failed to connect to matchmaking server.';
            isSearching = false;
            setTimeout(() => resetLobby(), 3000);
        });

        socket.on('match_found', (data) => {
            console.log('Match found:', data);
            handleMatchFound(data);
        });

        socket.on('queue_update', (data) => {
            document.getElementById('search-status').innerText = data.message;
            if (data.position > 1) {
                document.getElementById('queue-position').innerText = `Position in queue: ${data.position}`;
            }
        });

        socket.on('timeout', (data) => {
            console.log('Matchmaking timeout:', data);
            document.getElementById('search-status').innerText = data.message;
            isSearching = false;
            setTimeout(() => resetLobby(), 3000);
        });

        socket.on('error', (data) => {
            console.error('Broker error:', data);
            document.getElementById('search-status').innerText = data.message || 'Server error occurred.';
            isSearching = false;
            setTimeout(() => resetLobby(), 3000);
        });

        socket.on('disconnect', (reason) => {
            console.log('Disconnected from broker:', reason);
            if (isSearching) {
                document.getElementById('search-status').innerText = 'Disconnected from server.';
                isSearching = false;
                setTimeout(() => resetLobby(), 2000);
            }
        });

    } catch (error) {
        console.error('Failed to initialize socket:', error);
        document.getElementById('search-status').innerText = 'Failed to initialize connection.';
        isSearching = false;
        setTimeout(() => resetLobby(), 3000);
    }
}

function createPeerForMatchmaking() {
    // Destroy existing peer if any
    if (peer) peer.destroy();
    
    // Create new peer without ID (auto-generate)
    peer = new Peer(undefined, {
        debug: 1
    });

    peer.on('open', (id) => {
        myPeerID = id;
        console.log('My Peer ID:', id);
        document.getElementById('search-status').innerText = 'Peer ID generated. Joining queue...';
        
        // Join matchmaking queue
        if (socket && socket.connected) {
            socket.emit('join_queue', { peerId: myPeerID });
        }
    });

    peer.on('connection', (c) => {
        console.log('Incoming connection from:', c.peer);
        conn = c;
        setupConnection();
        
        // Wait for connection to be open
        if (conn.open) {
            handleConnectionReady();
        } else {
            conn.on('open', handleConnectionReady);
        }
    });

    peer.on('error', (err) => {
        console.error('PeerJS error:', err);
        if (isSearching) {
            document.getElementById('search-status').innerText = 'PeerJS error: ' + err.type;
            isSearching = false;
            setTimeout(() => resetLobby(), 3000);
        }
    });

    peer.on('disconnected', () => {
        console.log('Peer disconnected');
        if (isSearching) {
            resetLobby();
        }
    });
}

function handleMatchFound(data) {
    if (!peer || !peer.id) {
        console.error('Peer not ready when match found');
        return;
    }

    isHost = data.role === 'host';
    const targetPeerId = data.opponentId;
    
    console.log(`Match found! Role: ${isHost ? 'HOST' : 'GUEST'}, Target: ${targetPeerId}`);
    
    showConnectingUI();

    if (isHost) {
        // Host connects to guest
        console.log('Host connecting to:', targetPeerId);
        conn = peer.connect(targetPeerId, { reliable: true });
        setupConnection();
        
        conn.on('open', handleConnectionReady);
        conn.on('error', (err) => {
            console.error('Connection error:', err);
            document.getElementById('connecting-status').innerText = 'Connection failed. Please try again.';
            setTimeout(() => resetLobby(), 3000);
        });
    } else {
        // Guest waits for host connection (already set up in peer.on('connection'))
        document.getElementById('connecting-status').innerText = 'Waiting for host connection...';
        
        // Set a timeout in case connection doesn't come
        matchmakingTimeout = setTimeout(() => {
            if (!conn || !conn.open) {
                document.getElementById('connecting-status').innerText = 'Connection timeout. Please try again.';
                setTimeout(() => resetLobby(), 2000);
            }
        }, 15000);
    }
}

function setupConnection() {
    if (!conn) return;

    conn.on('open', () => { 
        console.log("P2P connection established"); 
        // Connection ready handler is called separately
    });
    
    conn.on('data', (data) => { 
        console.log("Received data:", data.type); 
        handleNetworkData(data); 
    });
    
    conn.on('close', () => { 
        console.log("Connection closed");
        if(gameState !== 'GAMEOVER' && gameState !== 'MENU') {
            endGame("DISCONNECTED", "Opponent left the game"); 
        }
    });

    conn.on('error', (err) => {
        console.error('Connection error:', err);
        if (gameState === 'PLAYING') {
            endGame("ERROR", "Connection error occurred");
        }
    });
}

function handleConnectionReady() {
    console.log('Connection ready - starting game');
    
    // Clear any timeouts
    if (matchmakingTimeout) {
        clearTimeout(matchmakingTimeout);
        matchmakingTimeout = null;
    }

    // Hide all lobby screens
    document.getElementById('lobby-screen').classList.add('hidden');
    document.getElementById('lobby-connecting').classList.add('hidden');
    
    // Notify broker that matchmaking is complete
    if (socket && socket.connected) {
        socket.emit('leave_queue');
    }

    // Start the game
    if (isHost) {
        startMultiplayerGame();
    }
    // For guest, we wait for START_GAME message from host
}

function cancelMatchmaking() {
    if (socket && socket.connected) {
        socket.emit('leave_queue');
    }
    resetLobby();
}

// --- REMATCH LOGIC (Updated for matchmaking) ---

function requestRematch() {
    if(!rematchMe) {
        rematchMe = true;
        document.getElementById('btn-rematch').classList.add('btn-secondary');
        document.getElementById('btn-rematch').innerText = "REQUESTED";
        document.getElementById('rematch-msg').classList.remove('hidden');
        if(conn) conn.send({ type: 'REQUEST_REMATCH' });
        checkRematchStart();
    }
}

function checkRematchStart() {
    if(rematchMe && rematchOpp) {
        document.getElementById('game-over').style.display = 'none';
        resetGameVars();
        if(isHost) startMultiplayerGame();
    }
}

function resetGameVars() {
    rematchMe = false; rematchOpp = false;
    document.getElementById('btn-rematch').classList.remove('btn-secondary');
    document.getElementById('btn-rematch').innerText = "REMATCH";
    document.getElementById('rematch-msg').classList.add('hidden');
    projectiles = [];
    blindMode = false; blindIntensity = 0; mustPlayBasic = false; canParry = false;
}

function requestRematch() {
    if(!rematchMe) {
        rematchMe = true;
        document.getElementById('btn-rematch').classList.add('btn-secondary');
        document.getElementById('btn-rematch').innerText = "REQUESTED";
        document.getElementById('rematch-msg').classList.remove('hidden');
        if(conn) conn.send({ type: 'REQUEST_REMATCH' });
        checkRematchStart();
    }
}

function checkRematchStart() {
    if(rematchMe && rematchOpp) {
        document.getElementById('game-over').style.display = 'none';
        resetGameVars();
        if(isHost) startMultiplayerGame();
    }
}

function resetGameVars() {
    rematchMe = false; rematchOpp = false;
    document.getElementById('btn-rematch').classList.remove('btn-secondary');
    document.getElementById('btn-rematch').innerText = "REMATCH";
    document.getElementById('rematch-msg').classList.add('hidden');
    projectiles = [];
    blindMode = false; blindIntensity = 0; mustPlayBasic = false; canParry = false;
}

// --- DATA HANDLING ---
function handleNetworkData(data) {
    if (data.type === 'START_GAME') {
        resetGameVars();
        document.getElementById('lobby-screen').classList.add('hidden');
        document.getElementById('lobby-connecting').classList.add('hidden');
        document.getElementById('game-over').style.display = 'none';
        hideLoading(); gameState = 'PLAYING';
        turn = data.turn === 'p2' ? 'me' : 'opponent';
        let myStartCards = data.p2Hand.map(c => new Card(c.suit, c.value, true));
        let topCard = new Card(data.topDiscard.suit, data.topDiscard.value, true);
        playDealAnimation(myStartCards, data.p1HandCount, topCard);
    } else if (data.type === 'OPPONENT_MOVE') {
        processOpponentMove(data.card, data.isCrit);
    } else if (data.type === 'OPPONENT_DRAW') {
        let c = new Card('fire', 1, false); 
        c.x = 60; c.y = height/2 + 30; c.isFaceUp = false;
        opponentHand.push(c);
        
        // Force opponent cards to recalculate positions immediately
        let oppScale = 0.8;
        let oppW = cardW * oppScale;
        let oppH = cardH * oppScale;
        let oppSpread = Math.min(width / (opponentHand.length + 2), oppW * 0.8);
        let oppStart = width/2 - ((opponentHand.length - 1) * oppSpread) / 2;
        opponentHand.forEach((c, i) => {
            c.targetX = oppStart + i * oppSpread; 
            c.targetY = oppH * 0.6;
        });
        
        playSound('deal');
        showFloatingText("Opponent Drew", width/2, 100, "#aaa");
        turn = 'me';
    } else if (data.type === 'MOON_ATTACK') {
        if(opponentHand.length > 0) opponentHand.pop();
        // Force opponent cards to recalculate positions immediately
        let oppScale = 0.8;
        let oppW = cardW * oppScale;
        let oppH = cardH * oppScale;
        let oppSpread = Math.min(width / (opponentHand.length + 2), oppW * 0.8);
        let oppStart = width/2 - ((opponentHand.length - 1) * oppSpread) / 2;
        opponentHand.forEach((c, i) => {
            c.targetX = oppStart + i * oppSpread; 
            c.targetY = oppH * 0.6;
        });
        
        let moonC = new Card('moon', 0, false); moonC.x = width/2; moonC.y = -100;
        moonC.targetX = width/2; moonC.targetY = height/2;
        discardPile.push(moonC);
        setTimeout(() => {
            spawnExplosion(width/2, height/2, COLORS.moon); playSound('moon');
            blindMode = true; blindIntensity = 1.0; 
            showFloatingText("BLINDED!", width/2, height/2, "#FFF");
        }, 300);
    } else if (data.type === 'MOON_FOLLOWUP') {
        processOpponentMove(data.card, data.isCrit);
        showFloatingText("ONE SHOT CHANCE", width/2, height/2 + 50, "red");
    } else if (data.type === 'BLIND_CLEARED') {
        blindMode = false; blindIntensity = 0;
        showFloatingText("DARKNESS FADED", width/2, height/2, "#FFF");
        processOpponentMove(data.card, data.isCrit);
    } else if (data.type === 'BLIND_FAIL') {
        showFloatingText("MISSED!", width/2, 150, "red"); turn = 'me'; 
    } else if (data.type === 'PARRY_SUCCESS') {
        projectiles = []; 
        showFloatingText("PARRIED!", width/2, height/2, COLORS.mirror);
        playSound('parry');
        spawnProjectiles(true, false);
        
        // Handle opponent's mirror card removal from their hand
        if (data.card && data.card.suit === 'mirror') {
            // Remove the mirror card from opponent's hand visually
            if (opponentHand.length > 0) {
                opponentHand.pop(); // Remove the card they used for parry
                
                // Force opponent cards to recalculate positions immediately
                let oppScale = 0.8;
                let oppW = cardW * oppScale;
                let oppH = cardH * oppScale;
                let oppSpread = Math.min(width / (opponentHand.length + 2), oppW * 0.8);
                let oppStart = width/2 - ((opponentHand.length - 1) * oppSpread) / 2;
                opponentHand.forEach((c, i) => {
                    c.targetX = oppStart + i * oppSpread; 
                    c.targetY = oppH * 0.6;
                });
            }
            // Add the mirror card to discard pile to show it was played
            let mirrorCard = new Card('mirror', 0, false);
            mirrorCard.x = width/2; mirrorCard.y = -100;
            mirrorCard.targetX = width/2; mirrorCard.targetY = height/2;
            discardPile.push(mirrorCard);
        }
    } else if (data.type === 'REQUEST_REMATCH') {
        rematchOpp = true;
        showFloatingText("Opponent wants rematch!", width/2, height/2, "#fff");
        checkRematchStart();
    } else if (data.type === 'PENALTY_SYNC') {
        // Handle penalty sync from opponent (used in projectile system)
        console.log('Penalty sync received');
    }
}

// --- GAME LOGIC ---
function startMultiplayerGame() {
    console.log("Starting Multiplayer Game Logic...");
    document.getElementById('lobby-screen').classList.add('hidden');
    gameState = 'PLAYING';
    
    function generateHand() {
        let h = [];
        h.push({suit: 'fire', value: Math.ceil(Math.random()*9)});
        h.push({suit: 'water', value: Math.ceil(Math.random()*9)});
        h.push({suit: 'leaf', value: Math.ceil(Math.random()*9)});
        h.push({suit: 'moon', value: 0});
        h.push({suit: 'mirror', value: 0});
        
        let r = Math.random();
        if(r < 0.1) h.push({suit: 'moon', value:0});
        else if(r < 0.2) h.push({suit: 'mirror', value:0});
        else {
            let s = BASIC_SUITS[Math.floor(Math.random()*3)];
            h.push({suit: s, value: Math.ceil(Math.random()*9)});
        }
        
        for (let i = h.length - 1; i > 0; i--) { 
            const j = Math.floor(Math.random() * (i + 1)); 
            [h[i], h[j]] = [h[j], h[i]]; 
        }
        return h;
    }

    let p1H = generateHand();
    let p2H = generateHand();
    let deckCount = 30; 
    let top = {suit: BASIC_SUITS[Math.floor(Math.random()*3)], value: Math.ceil(Math.random()*9)};
    
    let myStartCards = p1H.map(c => new Card(c.suit, c.value, true));
    let topCardObj = new Card(top.suit, top.value, true);
    turn = Math.random() > 0.5 ? 'me' : 'opponent';

    conn.send({
        type: 'START_GAME', deckCount: deckCount, topDiscard: top,
        p1HandCount: 6, p2Hand: p2H, turn: turn === 'me' ? 'p1' : 'p2'
    });
    playDealAnimation(myStartCards, 6, topCardObj);
}

function playDealAnimation(myCards, oppCount, topCard) {
    isAnimating = true; myHand = []; opponentHand = []; discardPile = [];
    let dealSpeed = 100; let totalCards = myCards.length + oppCount; let dealt = 0;
    
    let dealInterval = setInterval(() => {
        if (dealt >= totalCards) {
            clearInterval(dealInterval);
            setTimeout(() => {
                topCard.x = 60; topCard.y = height/2 + 30; discardPile.push(topCard);
                playSound('play'); isAnimating = false;
                setTimeout(() => { showFloatingText(turn === 'me' ? "YOUR TURN" : "OPPONENT'S TURN", width/2, height/2 + 100, turn==='me'?"#0f0":"#fff"); }, 500);
            }, 300);
            return;
        }
        
        let c;
        if (dealt % 2 === 0) {
            c = new Card('fire', 1, false); 
            c.x = 60; c.y = height/2 + 30; c.isFaceUp = false;
            opponentHand.push(c);
        } else {
            let cardIndex = Math.floor(dealt / 2);
            if (myCards[cardIndex]) {
                c = myCards[cardIndex]; 
                c.x = 60; c.y = height/2 + 30;
                c.isFaceUp = false; 
                myHand.push(c);
            }
        }
        playSound('deal'); dealt++;
    }, dealSpeed);
}

function isValidMove(card, topCard) {
    if (card.suit === 'mirror') return true; 
    if (card.suit === 'moon') return true; 
    if (topCard.suit === 'moon' || topCard.suit === 'mirror') return true; 
    return card.suit === topCard.suit || card.value === topCard.value;
}

function playerInput(cardIndex) {
    if (gameState !== 'PLAYING' || isAnimating) return false;
    
    let card = myHand[cardIndex];
    let top = discardPile[discardPile.length - 1];
    card.isDragging = false; 

    // --- LOGIKA PARRY ---
    if (canParry) {
        if (card.suit === 'mirror') {
            executeMove(cardIndex, card, top, false);
            projectiles.forEach(p => { p.speed = 15; p.targetIsMe = false; p.isSlow = false; }); 
            showFloatingText("MIRROR PARRY!", width/2, height/2, COLORS.mirror);
            playSound('parry');
            canParry = false;
            conn.send({ type: 'PARRY_SUCCESS', card: { suit: card.suit, value: card.value } });
            return true;
        } else {
            showFloatingText("USE MIRROR!", card.x, card.y - 70, "red");
            card.shake = 20; playSound('error');
            return false;
        }
    }

    if (turn !== 'me') return false;

    if (blindMode && blindIntensity === 1.0) {
        if (isValidMove(card, top)) {
            executeMove(cardIndex, card, top, false);
            blindMode = false; blindIntensity = 0;
            conn.send({ 
                type: 'BLIND_CLEARED', card: { suit: card.suit, value: card.value },
                isCrit: (COUNTER_MAP[card.suit] === top.suit)
            });
            return true;
        } else {
            card.shake = 30; playSound('error');
            showFloatingText("WRONG CARD!", card.x, card.y - 70, "red");
            turn = 'opponent'; 
            conn.send({ type: 'BLIND_FAIL' });
            return false;
        }
    }

    if (mustPlayBasic) {
        if (card.suit === 'moon' || card.suit === 'mirror') {
            card.shake = 20; showFloatingText("Basic Card Only!", card.x, card.y - 70, "red");
            return false;
        }
        if (!BASIC_SUITS.includes(card.suit)) return false;
    }

    if (isValidMove(card, top)) {
        if (card.suit === 'moon') {
            executeMove(cardIndex, card, top, false);
            spawnExplosion(width/2, height/2, COLORS.moon);
            playSound('moon');
            canParry = false; 
            blindMode = true; 
            blindIntensity = 0.1; 
            mustPlayBasic = true; 
            turn = 'me'; 
            showFloatingText("EXTRA TURN (Basic Only)", width/2, height/2 + 100, COLORS.moon);
            conn.send({ type: 'MOON_ATTACK' });
        } else if (card.suit === 'mirror') {
            executeMove(cardIndex, card, top, false);
            playSound('play');
            turn = 'me'; 
            showFloatingText("EXTRA TURN", width/2, height/2 + 100, COLORS.mirror);
            conn.send({ type: 'OPPONENT_MOVE', card: {suit: card.suit, value: card.value}, isCrit: false }); 
        } else {
            let isCrit = COUNTER_MAP[card.suit] === top.suit;
            executeMove(cardIndex, card, top, isCrit);
            if (mustPlayBasic) {
                mustPlayBasic = false;
                conn.send({ type: 'MOON_FOLLOWUP', card: { suit: card.suit, value: card.value }, isCrit: isCrit });
                turn = 'opponent'; 
            } else {
                conn.send({ type: 'OPPONENT_MOVE', card: { suit: card.suit, value: card.value }, isCrit: isCrit });
                turn = 'opponent';
            }
        }
        if(myHand.length === 0) endGame("YOU WIN!", "Victory Achieved");
        return true;
    } else {
        card.shake = 20;
        showFloatingText("Invalid Move", card.x, card.y - 50, "red");
        playSound('error');
        return false;
    }
}

function executeMove(index, card, top, isCrit) {
    card.isSelected = false;
    selectedIdx = -1;

    myHand.splice(index, 1);
    discardPile.push(card);
    card.targetX = width/2; 
    card.targetY = height/2;
    card.isAnimatingPos = false; 
    playSound('play');

    if(isCrit) {
        playSound('crit');
        showFloatingText("CRITICAL! (+2)", width/2, height/2 - 50, COLORS[card.suit]);
    }
}

function spawnProjectiles(targetIsMe, slowMotion) {
    projectiles.push(new ProjectileCard(targetIsMe, slowMotion));
    setTimeout(() => projectiles.push(new ProjectileCard(targetIsMe, slowMotion)), 200);
}

function processOpponentMove(cardData, isCrit) {
    let card = new Card(cardData.suit, cardData.value, false);
    
    // Remove card from opponent's hand BEFORE checking for mirror special case
    if(opponentHand.length > 0) opponentHand.pop();
    
    // Force opponent cards to recalculate positions immediately
    let oppScale = 0.8;
    let oppW = cardW * oppScale;
    let oppH = cardH * oppScale;
    let oppSpread = Math.min(width / (opponentHand.length + 2), oppW * 0.8);
    let oppStart = width/2 - ((opponentHand.length - 1) * oppSpread) / 2;
    opponentHand.forEach((c, i) => {
        c.targetX = oppStart + i * oppSpread; 
        c.targetY = oppH * 0.6;
    });
    
    card.x = width/2; card.y = -100;
    card.targetX = width/2; card.targetY = height/2;
    discardPile.push(card);
    playSound('play');
    
    if(cardData.suit === 'mirror') {
        showFloatingText("OPPONENT MIRROR!", width/2, height/2, COLORS.mirror);
        turn = 'opponent'; 
        return;
    }

    if(isCrit) {
        playSound('crit'); showFloatingText("CRITICAL INCOMING!", width/2, height/2 - 50, COLORS[cardData.suit]);
        
        let hasMirror = myHand.some(c => c.suit === 'mirror');
        
        if (hasMirror) {
            spawnProjectiles(true, true); 
            canParry = true;
            showFloatingText("USE MIRROR TO PARRY!", width/2, height/2 + 50, "#00FFFF");
        } else {
            spawnProjectiles(true, false); 
        }
    }
    
    setTimeout(() => { if(opponentHand.length === 0) endGame("YOU LOSE", "Opponent cleared their hand"); }, 500);
    turn = 'me';
}

function requestDraw() {
    if (gameState !== 'PLAYING' || turn !== 'me' || isAnimating || canParry) return;
    
    let newCard;
    if(isHost) newCard = drawCardFromDeckLogic();
    else {
        let r = Math.random();
        if(r < 0.05) newCard = new Card('moon', 0, true);
        else if (r < 0.08) newCard = new Card('mirror', 0, true);
        else {
            let s = BASIC_SUITS[Math.floor(Math.random()*3)]; let v = Math.floor(Math.random()*9)+1;
            newCard = new Card(s, v, true);
        }
    }

    if(newCard) {
        newCard.x = 60; 
        newCard.y = height/2 + 30; 
        newCard.isFaceUp = false; 
        
        myHand.push(newCard); 
        playSound('deal');
        
        if (mustPlayBasic) {
            mustPlayBasic = false; conn.send({ type: 'OPPONENT_DRAW' }); turn = 'opponent';
            showFloatingText("Combo Skipped", width/2, height/2, "#aaa");
        } else {
            conn.send({ type: 'OPPONENT_DRAW' }); turn = 'opponent'; showFloatingText("Turn Ended", width/2, height/2, "#aaa");
        }
    }
}

function drawCardFromDeckLogic() {
    let r = Math.random(); 
    if(r < 0.05) return new Card('moon', 0, true);
    if(r < 0.08) return new Card('mirror', 0, true);
    let s = BASIC_SUITS[Math.floor(Math.random()*3)]; let v = Math.floor(Math.random()*9)+1;
    return new Card(s, v, true);
}

function spawnExplosion(x, y, color) { for(let i=0; i<30; i++) particles.push(new Particle(x, y, color, true)); }

function endGame(title, subtitle) {
    gameState = 'GAMEOVER';
    document.getElementById('winner-text').innerText = title;
    document.getElementById('sub-winner-text').innerText = subtitle;
    document.getElementById('game-over').style.display = 'block';
}

// --- RENDER LOOP ---
function draw() {
    ctx.clearRect(0, 0, canvas.width / (window.devicePixelRatio||1), canvas.height / (window.devicePixelRatio||1));
    
    projectiles.forEach(p => p.draw(ctx));

    let deckX = 60; let deckY = height / 2 + 30;
    if (IMAGES.back) {
        let stackHeight = 15;
        for (let i = 0; i < stackHeight; i++) {
            let off = i * 0.5; 
            ctx.save();
            ctx.translate(deckX - off, deckY - off);
            ctx.shadowColor = 'rgba(0,0,0,0.5)';
            ctx.shadowBlur = i === stackHeight - 1 ? 5 : 0; 
            ctx.drawImage(IMAGES.back, -cardW/2, -cardH/2, cardW, cardH);
            ctx.restore();
        }
    } else {
        ctx.fillStyle = '#333'; ctx.fillRect(deckX - cardW/2, deckY - cardH/2, cardW, cardH);
    }

    if (discardPile.length > 0) {
        let startIdx = Math.max(0, discardPile.length - 3);
        for(let i = startIdx; i < discardPile.length; i++) {
            let c = discardPile[i];
            
            c.targetX = width/2;
            c.targetY = height/2;

            if(!isAnimating && Math.abs(c.x - width/2) < 5) c.x = width/2;
            if(!isAnimating && Math.abs(c.y - height/2) < 5) c.y = height/2;
            
            c.draw(ctx, true, undefined, undefined, cardW, cardH);
        }
    } else {
        ctx.strokeStyle = 'rgba(255,255,255,0.1)'; ctx.lineWidth = 2;
        roundRect(ctx, width/2 - cardW/2, height/2 - cardH/2, cardW, cardH, 10); ctx.stroke();
    }

    let oppScale = 0.8;
    let oppW = cardW * oppScale;
    let oppH = cardH * oppScale;
    let oppSpread = Math.min(width / (opponentHand.length + 2), oppW * 0.8);
    let oppStart = width/2 - ((opponentHand.length - 1) * oppSpread) / 2;
    
    opponentHand.forEach((c, i) => {
        c.targetX = oppStart + i * oppSpread; 
        c.targetY = oppH * 0.6; 
        c.draw(ctx, false, undefined, undefined, oppW, oppH);
    });

    if (blindMode) { ctx.fillStyle = `rgba(0, 0, 0, ${blindIntensity})`; ctx.fillRect(0, 0, width, height); }

    let pSpread = Math.min(width / (myHand.length + 1), cardW + 10);
    let pStart = width/2 - ((myHand.length - 1) * pSpread) / 2;
    let handYOffset = (blindMode && blindIntensity === 1.0) ? -50 : 0;
    
    myHand.forEach((c, i) => {
        if (!c.isDragging && !c.isAnimatingPos) {
            c.targetX = pStart + i * pSpread;
            let baseHeight = height - (cardH * 0.5); 
            if (c.isSelected) baseHeight = height - (cardH * 1.0);
            else if (c.isHovered) baseHeight = height - (cardH * 0.65);
            c.targetY = baseHeight + handYOffset;
        }
        
        if (i !== dragIdx) {
            c.draw(ctx, undefined, undefined, undefined, cardW, cardH);
        }
    });

    if (dragIdx !== -1 && myHand[dragIdx]) {
        let c = myHand[dragIdx];
        c.draw(ctx, undefined, c.x, c.y, cardW, cardH);
    }

    particles.forEach(p => p.draw(ctx));
    floatingTexts.forEach(t => t.draw(ctx));

    if(gameState === 'PLAYING' && !isAnimating) {
        ctx.font = "bold 16px Orbitron"; ctx.fillStyle = turn === 'me' ? '#00FF00' : '#888'; ctx.textAlign = 'center';
        let txt = turn === 'me' ? "YOUR TURN" : "OPPONENT'S TURN";
        if(mustPlayBasic) txt = "COMBO: PLAY BASIC CARD!";
        if(canParry) txt = "!!! PARRY CHANCE !!!";
        if(blindMode && blindIntensity === 1.0 && turn === 'me') txt = "GUESS THE CARD!";
        ctx.fillText(txt, width/2, height/2 + cardH/2 + 50);
    }
}

function update() {
    for (let i = particles.length - 1; i >= 0; i--) { particles[i].update(); if (particles[i].life <= 0) particles.splice(i, 1); }
    for (let i = floatingTexts.length - 1; i >= 0; i--) { floatingTexts[i].update(); if (floatingTexts[i].life <= 0) floatingTexts.splice(i, 1); }
    
    for (let i = projectiles.length - 1; i >= 0; i--) {
        let p = projectiles[i];
        p.update();
        if (p.isDead) {
            if (p.targetIsMe) {
                let c = drawCardFromDeckLogic();
                c.x = width/2; c.y = height; c.isFaceUp = false;
                myHand.push(c); playSound('deal');
                conn.send({ type: 'PENALTY_SYNC' }); 
                canParry = false; 
            } else {
                let c = new Card('fire', 1, false); c.x = width/2; c.y = 0;
                opponentHand.push(c);
                
                // Force opponent cards to recalculate positions immediately
                let oppScale = 0.8;
                let oppW = cardW * oppScale;
                let oppH = cardH * oppScale;
                let oppSpread = Math.min(width / (opponentHand.length + 2), oppW * 0.8);
                let oppStart = width/2 - ((opponentHand.length - 1) * oppSpread) / 2;
                opponentHand.forEach((c, i) => {
                    c.targetX = oppStart + i * oppSpread; 
                    c.targetY = oppH * 0.6;
                });
                
                playSound('deal');
            }
            projectiles.splice(i, 1);
        }
    }
}
function loop() { update(); draw(); requestAnimationFrame(loop); }

function resize() { 
    const dpr = window.devicePixelRatio || 1;
    canvas.width = window.innerWidth * dpr;
    canvas.height = window.innerHeight * dpr;
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    ctx.scale(dpr, dpr);
    width = window.innerWidth; height = window.innerHeight;

    let refWidth = Math.min(width, 500);
    cardScale = refWidth / 500; 
    cardW = Math.max(60, 100 * cardScale); 
    cardH = cardW / CARD_RATIO;
}

function getCardAt(x, y) {
    for (let i = myHand.length - 1; i >= 0; i--) {
        let c = myHand[i];
        if (x > c.x - cardW/2 && x < c.x + cardW/2 && 
            y > c.y - cardH/2 && y < c.y + cardH/2) {
            return i;
        }
    }
    return -1;
}

function onPointerDown(e) {
      if (audioCtx.state === 'suspended') audioCtx.resume();
    startBGM(); // Mencoba menyalakan BGM saat interaksi pertama
    // =====================

    if (gameState !== 'PLAYING' || isAnimating || (turn !== 'me' && !canParry)) return;
    if (gameState !== 'PLAYING' || isAnimating || (turn !== 'me' && !canParry)) return;
    
    if (audioCtx.state === 'suspended') audioCtx.resume();

    let rect = canvas.getBoundingClientRect();
    let x = (e.clientX || e.touches[0].clientX) - rect.left;
    let y = (e.clientY || e.touches[0].clientY) - rect.top;
    
    let deckX = 60; let deckY = height/2 + 30;
    if (x > deckX - cardW/2 - 20 && x < deckX + cardW/2 + 20 &&
        y > deckY - cardH/2 - 20 && y < deckY + cardH/2 + 20) {
        if (!blindMode || blindIntensity < 0.5) requestDraw();
        return;
    }

    let idx = getCardAt(x, y);

    if (idx !== -1) {
        if (selectedIdx === idx) {
             let success = playerInput(idx);
             if (success) {
                 selectedIdx = -1;
                 dragIdx = -1;
                 return;
             }
        }

        if (selectedIdx !== -1 && selectedIdx !== idx && myHand[selectedIdx]) {
            myHand[selectedIdx].isSelected = false;
        }

        selectedIdx = idx;
        dragIdx = idx; 
        
        let c = myHand[idx];
        c.isSelected = true;
        c.isDragging = true;
        c.isAnimatingPos = false; 
        
        dragOffsetX = x - c.x;
        dragOffsetY = y - c.y;
        
        playSound('deal'); 
    } else {
        if(selectedIdx !== -1 && myHand[selectedIdx]) {
            myHand[selectedIdx].isSelected = false;
            selectedIdx = -1;
        }
    }
}

function onPointerMove(e) {
    let rect = canvas.getBoundingClientRect();
    let x = (e.clientX || (e.touches ? e.touches[0].clientX : 0)) - rect.left;
    let y = (e.clientY || (e.touches ? e.touches[0].clientY : 0)) - rect.top;

    if (dragIdx !== -1) {
        e.preventDefault(); 
        myHand[dragIdx].x = x - dragOffsetX;
        myHand[dragIdx].y = y - dragOffsetY;
    } else {
        let hovered = false;
        for (let i = myHand.length - 1; i >= 0; i--) {
            let c = myHand[i];
            if (!hovered && x > c.x - cardW/2 && x < c.x + cardW/2 && 
                y > c.y - cardH/2 && y < c.y + cardH/2) {
                c.isHovered = true; hovered = true;
            } else c.isHovered = false;
        }
    }
}

function onPointerUp(e) {
    if (dragIdx !== -1) {
        let c = myHand[dragIdx];
        c.isDragging = false;
        
        let dist = Math.hypot(c.x - width/2, c.y - height/2);
        
        if (dist < 150) {
            let success = playerInput(dragIdx);
            if (!success) {
                c.isAnimatingPos = false; 
            }
        }
        dragIdx = -1;
    }
}

window.addEventListener('resize', resize);
canvas.addEventListener('mousedown', onPointerDown);
canvas.addEventListener('mousemove', onPointerMove);
window.addEventListener('mouseup', onPointerUp);

canvas.addEventListener('touchstart', onPointerDown, {passive: false});
canvas.addEventListener('touchmove', onPointerMove, {passive: false});
window.addEventListener('touchend', onPointerUp);

function roundRect(ctx, x, y, w, h, r) { ctx.beginPath(); ctx.roundRect(x, y, w, h, r); ctx.closePath(); }
function showFloatingText(txt, x, y, c) { 
    floatingTexts.push({ text: txt, x: x, y: y, color: c, life: 1, update: function(){this.y-=1.5; this.life-=0.02;}, draw: function(ctx){
        ctx.globalAlpha=Math.max(0,this.life); ctx.fillStyle=this.color; ctx.strokeStyle='#000'; ctx.lineWidth=3;
        ctx.font="bold 24px Orbitron"; ctx.strokeText(this.text,this.x,this.y); ctx.fillText(this.text,this.x,this.y); ctx.globalAlpha=1;
    }});
}

resize();
loadAssets();
loop();
</script>
</body>
</html>
